/// VRAM controller (AXI master)
/// Convert the write stream (WADDRVLD/WADDR + WDATAVLD/WDATA/WSTRB/WLAST)
/// coming from drw_proc to AXI Write (AW/W/B) and write to DDR (VRAM).
pub module drw_vramctrl (
    CLK  : input clock           ,
    ARST : input reset           ,
    RSTS : input reset           ,
    START: input logic           ,
    RESOL: input Resolution::Mode,

    // write stream from proc
    IN_WREADY: output logic    ,
    WADDRVLD : input  logic    ,
    WADDR    : input  logic<32>,
    WDATAVLD : input  logic    ,
    WDATA_IN : input  logic<32>,
    WSTRB_IN : input  logic<4> ,
    WLAST_IN : input  logic    ,

    // read stream to proc
    SDATAVLD: output logic    ,
    SDATA   : output logic<32>,

    // status
    BUSY: output logic,

    // AXI read address channel
    ARADDR : output logic<32>,
    ARLEN  : output logic<4> ,
    ARVALID: output logic    ,
    ARREADY: input  logic    ,

    // AXI read data channel
    RDATA : input  logic<32>,
    RLAST : input  logic    ,
    RVALID: input  logic    ,
    RREADY: output logic    ,

    // write address channel
    AWADDR : output logic<32>,
    AWLEN  : output logic<4> ,
    AWVALID: output logic    ,
    AWREADY: input  logic    ,

    // write data channel
    WDATA : output logic<32>,
    WSTRB : output logic<4> ,
    WLAST : output logic    ,
    WVALID: output logic    ,
    WREADY: input  logic    ,

    // write response channel
    BRESP : input  logic<2>,
    BVALID: input  logic   ,
    BREADY: output logic   ,
) {
    // Reset definition (Combined ARST and RSTS)
    let rst: '_ default reset_sync_high = ARST | RSTS;

    const BURST_MAX: u32 = 16;

    var buf_data: logic<32> [BURST_MAX];
    var buf_strb: logic<4>  [BURST_MAX];

    var cap_addr: logic<32>;
    var cap_cnt : logic<5> ; // captured beats so far (0..16)

    // pending burst sending control
    var rem_len: logic<5>; // remaining beats to send (0..16)
    var rem_ofs: logic<5>; // offset in buffer (0..16)

    // current sub-burst (split by 4KB boundary)
    var cur_addr_reg: logic<32>;
    var cur_len_reg : logic<5> ; // 1..16
    var send_idx    : logic<5> ;

    enum State {
        capture,
        aw,
        w,
        b,
    }
    var state: State;

    // ---------------------------------------------------------------------
    // 4KB boundary split: compute current sub-burst length
    // ---------------------------------------------------------------------
    var aw_addr_comb: logic<32>;
    var cur_len_comb: logic<5> ;
    var bytes_left  : logic<13>;
    var maxbeats    : logic<11>;

    always_comb {
        aw_addr_comb = cap_addr + (rem_ofs << 2);

        // beats before crossing 4KB: (4096 - (addr[11:0])) / 4

        bytes_left = 13'd4096 - {1'b0, aw_addr_comb[11:0]};
        maxbeats   = bytes_left[12:2]; // /4
        if maxbeats == 11'd0 {
            maxbeats = 11'd1;
        }

        if maxbeats >= {6'd0, rem_len} {
            cur_len_comb = rem_len;
        } else {
            // rem_len<=16 なのでここに来る maxbeats は <16 のはず
            cur_len_comb = maxbeats[4:0];
        }

        if rem_len != 5'd0 && cur_len_comb == 5'd0 {
            cur_len_comb = 5'd1;
        }
    }

    // ---------------------------------------------------------------------
    // Input handshake (proc -> vramctrl)
    // ---------------------------------------------------------------------
    assign IN_WREADY = (state == State::capture) && (rem_len == 5'd0) && (cap_cnt <: BURST_MAX);
    let accept   : logic = IN_WREADY && WDATAVLD && ((cap_cnt != 5'd0) || WADDRVLD);

    // ---------------------------------------------------------------------
    // Single FSM: capture 1 burst -> emit (maybe split) AW/W/B -> repeat
    // ---------------------------------------------------------------------
    always_ff {
        if_reset {
            state        = State::capture;
            cap_addr     = 32'h0;
            cap_cnt      = 5'd0;
            rem_len      = 5'd0;
            rem_ofs      = 5'd0;
            cur_addr_reg = 32'h0;
            cur_len_reg  = 5'd0;
            send_idx     = 5'd0;
        } else {
            if START {
                state    = State::capture;
                cap_cnt  = 5'd0;
                rem_len  = 5'd0;
                rem_ofs  = 5'd0;
                send_idx = 5'd0;
            } else {
                case state {
                    State::capture: {
                        // TODO: impl
                    }
                    State::aw: {
                        // TODO: impl
                    }
                    State::w: {
                        // TODO: imp;
                    }
                    State::b: {
                        // TODO: impl
                    }
                    default: {
                        state = State::capture;
                    }
                }
            }
        }
    }

    // ---------------------------------------------------------------------
    // Outputs
    // ---------------------------------------------------------------------
    always_comb {
        ARADDR   = 32'h0;
        ARLEN    = 8'h0;
        ARVALID  = 1'b0;
        RREADY   = 1'b0;
        SDATAVLD = 1'b0;
        SDATA    = 32'h0;
    }

    // AW channel
    always_comb {
        AWADDR  = aw_addr_comb;
        AWLEN   = if (cur_len_comb == 5'd0) ? 8'd0 : {3'b000, (cur_len_comb - 5'd1)};
        AWVALID = (state == State::aw) && (rem_len != 5'd0);
    }

    // W channel
    always_comb {
        WVALID = (state == State::w);
        WDATA  = buf_data[rem_ofs + send_idx];
        WSTRB  = buf_strb[rem_ofs + send_idx];
        WLAST  = (state == State::w) && (send_idx == (cur_len_reg - 5'd1));
    }

    // B channel
    always_comb {
        BREADY = 1'b1; // TODO: STEP-2
    }

    // BUSY: sending or capturing partial burst
    always_comb {
        BUSY = (state != State::capture) || (rem_len != 5'd0) || (cap_cnt != 5'd0);
    }
}
