/// Command Analyzer and PATBLT generator
///
/// Commands
/// - NOP         (0x00)
/// - EODL        (0x0F)
/// - SETFRAME    (0x20)
/// - SETDRAWAREA (0x21)
/// - SETFCOLOR   (0x23)
pub module drw_proc (
    CLK  : input clock           ,
    ARST : input reset           ,
    RSTS : input reset           , // soft reset
    START: input logic           , // 1-cycle pulse
    RESOL: input Resolution::Mode,

    // command stream (from cmd FIFO)
    CMDFIFO_EMPTY: input  logic    ,
    CMDFIFO_RDATA: input  logic<32>,
    CMDFIFO_RDEN : output logic    ,

    // source data (for future BITBLT)
    DRWVC_SDATAVLD: input logic    ,
    DRWVC_SDATA   : input logic<32>,

    // write stream to vramctrl
    DRWVC_WREADY: input  logic    ,
    WADDRVLD    : output logic    ,
    WADDR       : output logic<32>,
    WDATAVLD    : output logic    ,
    WDATA       : output logic<32>,
    WSTRB       : output logic<4> ,
    WLAST       : output logic    ,

    // status/interrupt
    BUSY: output logic,
    INT : output logic,
) {
    let rst: '_ default reset_sync_high = ARST | RSTS;

    var cmd_rd_en   : logic;
    var cmd_rd_en_d1: logic;
    always_ff {
        if_reset {
            cmd_rd_en_d1 = 1'b0;
        } else {
            cmd_rd_en_d1 = cmd_rd_en;
        }
    }
    let cmd_valid: logic = cmd_rd_en_d1;

    const BURST_MAX: u32 = 16;

    enum State {
        idle,
        fetch,
        setframe2,
        setframe3,
        setarea2,
        setarea3,
        setcolor2,
        patblt2,
        patblt3,
        draw,
        eodl_done,
    }
    var state: State;

    var reg_frame_base: logic<32>;
    var reg_frame_w   : logic<11>;
    var reg_frame_h   : logic<11>;

    var reg_area_posx: logic<11>;
    var reg_area_posy: logic<11>;
    var reg_area_sizx: logic<11>;
    var reg_area_sizy: logic<11>;

    var reg_fcolor: logic<32>; // ARGB8888

    // PATBLT params
    var pat_dposx: signed logic<12>;
    var pat_dposy: signed logic<12>;

    // draw (clipped) region [x0, x1), [y0, y1)
    var draw_x0: logic<12>;
    var draw_x1: logic<12>;
    var draw_y0: logic<12>;
    var draw_y1: logic<12>;

    // iterators
    var cur_x: logic<12>;
    var cur_y: logic<12>;

    // current pixel address (bytes)
    var addr_reg: logic<32>;

    // burst control
    var burst_len: logic<5>; // 1..16
    var burst_idx: logic<5>; // 0..15

    // ----------------------------
    // command FIFO read (FWFT)
    // ----------------------------
    always_comb {
        cmd_rd_en = 1'b0;

        if !CMDFIFO_EMPTY {
            if (state == State::fetch) || (state == State::setframe2) || (state == State::setframe3) || (state == State::setarea2) || (state == State::setarea3) || (state == State::setcolor2) || (state == State::patblt2) || (state == State::patblt3 && !cmd_valid) {
                cmd_rd_en = 1'b1;
            }
        }
    }
    assign CMDFIFO_RDEN = cmd_rd_en;
    let cmd_fire    : logic = CMDFIFO_RDEN & ~CMDFIFO_EMPTY;

    // ----------------------------
    // output signals (combinational from state)
    // ----------------------------
    always_comb {
        // defaults
        WADDRVLD = 1'b0;
        WADDR    = 32'h0;
        WDATAVLD = 1'b0;
        WDATA    = 32'h0;
        WSTRB    = 4'h0;
        WLAST    = 1'b0;

        if state == State::draw {
            // data beat always valid while drawing
            WDATAVLD = 1'b1;
            WDATA    = reg_fcolor;
            WSTRB    = 4'hF;

            // at the first beat of each burst, present start address
            if burst_idx == 5'd0 {
                WADDRVLD = 1'b1;
                WADDR    = addr_reg;
            }

            // last beat in this burst
            if burst_idx == (burst_len - 5'd1) {
                WLAST = 1'b1;
            }
        }
    }

    // ----------------------------
    // BUSY
    // ----------------------------
    assign BUSY = (state != State::idle);

    // ----------------------------
    // main FSM (+ INT pulse)
    // ----------------------------
    always_ff {
        if_reset {
            state = State::idle;

            reg_frame_base = 32'h0;
            reg_frame_w    = 11'd0;
            reg_frame_h    = 11'd0;

            reg_area_posx = '0;
            reg_area_posy = '0;
            reg_area_sizx = 11'd0;
            reg_area_sizy = 11'd0;

            reg_fcolor = 32'h00000000;

            pat_dposx = '0;
            pat_dposy = '0;

            draw_x0 = 12'd0;
            draw_x1 = 12'd0;
            draw_y0 = 12'd0;
            draw_y1 = 12'd0;
            cur_x   = 12'd0;
            cur_y   = 12'd0;

            addr_reg  = 32'd0;
            burst_len = 5'd1;
            burst_idx = 5'd0;

            INT = 1'b0;
        } else {
            // default: INT pulse is 1-cycle
            INT = 1'b0;

            // START: begin new list
            if START {
                state = State::fetch;

                // reset any in-flight draw
                draw_x0 = 12'd0;
                draw_x1 = 12'd0;
                draw_y0 = 12'd0;
                draw_y1 = 12'd0;
                cur_x   = 12'd0;
                cur_y   = 12'd0;

                addr_reg  = 32'd0;
                burst_len = 5'd1;
                burst_idx = 5'd0;
            }

            case state {
                State::idle: {
                    // wait for START
                }
                // ------------------------
                // fetch opcode word
                // ------------------------
                State::fetch: {
                    if cmd_valid {
                        case CMDFIFO_RDATA[31:24] {
                            DrawOpcode::NOP: {
                                state = State::fetch;
                            }
                            DrawOpcode::EODL: {
                                state = State::eodl_done;
                            }
                            DrawOpcode::SETFRAME: {
                                state = State::setframe2;
                            }
                            DrawOpcode::SETDRAWAREA: {
                                state = State::setarea2;
                            }
                            DrawOpcode::SETFCOLOR: {
                                state = State::setcolor2;
                            }
                            DrawOpcode::SETBLENDOFF: {
                                state = State::fetch; // TODO: STEP-2
                            }
                            DrawOpcode::PATBLT: {
                                state = State::patblt2;
                            }
                            default: {
                                state = State::fetch;
                            }
                        }
                    }
                }
                // ------------------------
                // SETFRAME (3 words)
                //   word2: VRAMADR
                //   word3: WIDTH[26:16] HEIGHT[10:0]
                // ------------------------
                State::setframe2: {
                    if cmd_valid {
                        reg_frame_base = CMDFIFO_RDATA;
                        state          = State::setframe3;
                    }
                }
                State::setframe3: {
                    if cmd_valid {
                        reg_frame_w = CMDFIFO_RDATA[26:16];
                        reg_frame_h = CMDFIFO_RDATA[10:0];
                        state       = State::fetch;
                    }
                }
                // ------------------------
                // SETDRAWAREA (3 words)
                //   word2: POSX[26:16] (u11) POSY[10:0] (u11)
                //   word3: SIZX[26:16] (u11)      SIZY[10:0] (u11)
                // ------------------------
                State::setarea2: {
                    if cmd_valid {
                        reg_area_posx = CMDFIFO_RDATA[26:16];
                        reg_area_posy = CMDFIFO_RDATA[10:0];
                        state         = State::setarea3;
                    }
                }
                State::setarea3: {
                    if cmd_valid {
                        reg_area_sizx = CMDFIFO_RDATA[26:16];
                        reg_area_sizy = CMDFIFO_RDATA[10:0];
                        state         = State::fetch;
                    }
                }
                // ------------------------
                // SETFCOLOR (2 words)
                //   word2: A[31:24] R[23:16] G[15:8] B[7:0]
                // ------------------------
                State::setcolor2: {
                    // TODO: impl
                }
                // ------------------------
                // PATBLT (3 words)
                //   word2: DPOSX[27:16] (signed12), DPOSY[11:0] (signed12)
                //   word3: DSIZX[26:16] (u11),      DSIZY[10:0] (u11)
                // ------------------------
                State::patblt2: {
                    // TODO: impl
                }
                State::patblt3: {
                    // TODO: impl
                }
                // ------------------------
                // DRAW: stream pixels to vramctrl
                // ------------------------
                State::draw: {
                    // TODO: impl
                }
                // ------------------------
                // EODL
                // ------------------------
                State::eodl_done: {
                    // TODO: impl
                }
                default: {
                    state = State::idle;
                }
            }
        }
    }
}
