/// Command Analyzer and PATBLT generator
///
/// Commands
/// - NOP         (0x00)
/// - EODL        (0x0F)
/// - SETFRAME    (0x20)
/// - SETDRAWAREA (0x21)
/// - SETFCOLOR   (0x23)
pub module drw_proc (
    CLK  : input clock           ,
    ARST : input reset           ,
    RSTS : input reset           , // soft reset
    START: input logic           , // 1-cycle pulse
    RESOL: input Resolution::Mode,

    // command stream (from cmd FIFO)
    CMDFIFO_EMPTY: input  logic    ,
    CMDFIFO_RDATA: input  logic<32>,
    CMDFIFO_RDEN : output logic    ,

    // source data (for future BITBLT)
    DRWVC_SDATAVLD: input logic    ,
    DRWVC_SDATA   : input logic<32>,

    // write stream to vramctrl
    DRWVC_WREADY: input  logic    ,
    WADDRVLD    : output logic    ,
    WADDR       : output logic<32>,
    WDATAVLD    : output logic    ,
    WDATA       : output logic<32>,
    WSTRB       : output logic<4> ,
    WLAST       : output logic    ,

    // status/interrupt
    BUSY: output logic,
    INT : output logic,
) {
    let rst: '_ default reset_sync_high = ARST | RSTS;

    // ----------------------------
    // opcode definitions
    // ----------------------------
    const OPC_NOP        : logic<8> = 8'h00;
    const OPC_EODL       : logic<8> = 8'h0F;
    const OPC_SETFRAME   : logic<8> = 8'h20;
    const OPC_SETDRAWAREA: logic<8> = 8'h21;
    const OPC_SETFCOLOR  : logic<8> = 8'h23;
    const OPC_SETBLENDOFF: logic<8> = 8'h32;
    const OPC_PATBLT     : logic<8> = 8'h81;

    // internal burst split (beats)
    const BURST_MAX: u32 = 16;

    // ----------------------------
    // internal state registers
    // ----------------------------
    enum State {
        idle,
        fetch,
        setframe2,
        setframe3,
        setarea2,
        setarea3,
        setcolor2,
        patblt2,
        patblt3,
        draw,
        eodl_done,
    }

    var state: State;

    // TODO: define Vec2 struct

    // registers set by commands
    var reg_frame_base: logic<32>;
    var reg_frame_w   : logic<11>;
    var reg_frame_h   : logic<11>;

    var reg_area_posx: signed logic<11>;
    var reg_area_posy: signed logic<11>;
    var reg_area_sizx: logic       <11>;
    var reg_area_sizy: logic       <11>;

    var reg_fcolor: logic<32>; // ARGB8888

    // PATBLT params
    var pat_dposx: signed logic<12>;
    var pat_dposy: signed logic<12>;

    // draw (clipped) region [x0, x1) [y0, y1)
    var draw_x0: logic<12>;
    var draw_x1: logic<12>;
    var draw_y0: logic<12>;
    var draw_y1: logic<12>;

    // iterators
    var cur_x: logic<12>;
    var cur_y: logic<12>;

    // current pixel address (bytes)
    var addr_reg: logic<32>;

    // burst control
    var burst_len: logic<5>; // 1..16
    var burst_idx: logic<5>; // 0..15

    // helper: min(16, a)
    function min16 (
        a: input logic<12>,
    ) -> logic<5> {
        return if a >= 12'd16 ? 5'd16 : a[4:0];
    }

    // helper: compute address of (x, y) in bytes
    function pix_addr (
        base : input logic<32>,
        width: input logic<11>,
        x    : input logic<12>,
        y    : input logic<12>,
    ) -> logic<32> {
        let idx: logic<32> = (y * width) + x;
        return base + (idx << 2);
    }

    // ----------------------------
    // command FIFO read (FWFT)
    // ----------------------------
    always_comb {
        // defalt
        CMDFIFO_RDEN = 1'b0;

        // read a word when we are in a command-collection state and FIFO not empty,
        // and not currently drawing
        if (state == State::fetch) || (state == State::setframe2) || (state == State::setframe3) || (state == State::setarea2) || (state == State::setarea3) || (state == State::setcolor2) || (state == State::patblt2) || (state == State::patblt3) {
            if !CMDFIFO_EMPTY {
                CMDFIFO_RDEN = 1'b1;
            }
        }
    }
    let cmd_fire: logic = CMDFIFO_RDEN & ~CMDFIFO_EMPTY;

    // ----------------------------
    // output signals (combinational from state)
    // ----------------------------
    always_comb {
        // defaults
        WADDRVLD = 1'b0;
        WADDR    = 32'h0;
        WDATAVLD = 1'b0;
        WDATA    = 32'h0;
        WSTRB    = 4'h0;
        WLAST    = 1'b0;

        if state == State::draw {
            // data beat always valid while drawing
            WDATAVLD = 1'b1;
            WDATA    = reg_fcolor;
            WSTRB    = 4'hF;

            // at the first beat of each burst, present start address
            if burst_idx == 5'd0 {
                WADDRVLD = 1'b1;
                WADDR    = addr_reg;
            }

            // last beat in this burst
            if burst_idx == (burst_len - 5'd1) {
                WLAST = 1'b1;
            }
        }
    }

    // ----------------------------
    // BUSY
    // ----------------------------
    assign BUSY = (state != State::idle);

    // ----------------------------
    // main FSM (+ INT pulse)
    // ----------------------------
    always_ff {
        if_reset {
            state = State::idle;

            reg_frame_base = 32'h0;
            reg_frame_w    = 11'd0;
            reg_frame_h    = 11'd0;

            reg_area_posx = '0;
            reg_area_posy = '0;
            reg_area_sizx = 11'd0;
            reg_area_sizy = 11'd0;

            reg_fcolor = 32'h00000000;

            pat_dposx = '0;
            pat_dposy = '0;

            draw_x0 = 12'd0;
            draw_x1 = 12'd0;
            draw_y0 = 12'd0;
            draw_y1 = 12'd0;
            cur_x   = 12'd0;
            cur_y   = 12'd0;

            addr_reg  = 32'd0;
            burst_len = 5'd1;
            burst_idx = 5'd0;

            INT = 1'b0;
        } else {
            // default: INT pulse is 1-cycle
            INT = 1'b0;

            // START: begin new list
            if START {
                state = State::fetch;

                // reset any in-flight draw
                draw_x0 = 12'd0;
                draw_x1 = 12'd0;
                draw_y0 = 12'd0;
                draw_y1 = 12'd0;
                cur_x   = 12'd0;
                cur_y   = 12'd0;

                addr_reg  = 32'd0;
                burst_len = 5'd1;
                burst_idx = 5'd0;
            }

            case state {
                State::idle: {
                    // wait for START
                }
                // fetch opcode word
                State::fetch: {
                    if cmd_fire {
                        state = case CMDFIFO_RDATA[31:24] {
                            OPC_NOP        : State::fetch,
                            OPC_EODL       : State::eodl_done,
                            OPC_SETFRAME   : State::setframe2,
                            OPC_SETDRAWAREA: State::setarea2,
                            OPC_SETFCOLOR  : State::setcolor2,
                            OPC_SETBLENDOFF: State::fetch, // TODO: impl
                            OPC_PATBLT     : State::patblt2,
                            default        : State::fetch, // unknown opcode (treat as NOP)
                        };
                    }
                }
                // SETFRAME (3 words)
                // - word2: VRAMADR
                // - word3: WIDTH[21:11] HEIGHT[10:0]
                State::setframe2: {
                    if cmd_fire {
                        reg_frame_base = CMDFIFO_RDATA;
                        state          = State::setframe3;
                    }
                }
                State::setframe3: {
                    if cmd_fire {
                        reg_frame_w = CMDFIFO_RDATA[21:11];
                        reg_frame_h = CMDFIFO_RDATA[10:0];
                        state       = State::fetch;
                    }
                }
                // SETDRAWAREA (3 words)
                // - word2: POSX[21:11] (signed11) POSY[10:0] (signed11)
                // - word3: SIZX[21:11] (u11)      SIZY[10:0] (u11)
                State::setarea2: {
                    if cmd_fire {
                        reg_area_posx = $signed(CMDFIFO_RDATA[21:11]);
                        reg_area_posy = $signed(CMDFIFO_RDATA[10:0]);
                        state         = State::setarea3;
                    }
                }
                State::setarea3: {
                    if cmd_fire {
                        reg_area_sizx = CMDFIFO_RDATA[21:11];
                        reg_area_sizy = CMDFIFO_RDATA[10:0];
                        state         = State::fetch;
                    }
                }
                // SETFCOLOR (2 words)
                // - word2: A[31:24] R[23:16] G[15:8] B[7:0]
                State::setcolor2: {
                    if cmd_fire {
                        reg_fcolor = CMDFIFO_RDATA;
                        state      = State::fetch;
                    }
                }
                // PATBLT (3 words)
                // - word2: DPOSX[23:12] (signed12), DPOSY[11:0] (signed12)
                // - word3: DSIZX[22:12] (u11),      DSIZY[10:0] (u11)
                State::patblt2: {
                    if cmd_fire {
                        pat_dposx = $signed(CMDFIFO_RDATA[23:12]);
                        pat_dposy = $signed(CMDFIFO_RDATA[11:0]);
                        state     = State::patblt3;
                    }
                }
                State::patblt3: {
                    if cmd_fire {
                        // TODO: consider move these let things to always_comb block

                        // capture size directly from the word we just poped
                        let dsizx_new: logic<11> = CMDFIFO_RDATA[22:12];
                        let dsizy_new: logic<11> = CMDFIFO_RDATA[10:0];

                        // compute clipped region and initialize drawing
                        // rect: [dposx, dposx+dsizx) [dposy, dposy+dsizy)
                        // clip with draw area and frame bounds

                        let patx32 : signed logic<32> = $signed({{pat_dposx[11] repeat 20}, pat_dposx}); // 12 -> 32 (signed)
                        let paty32 : signed logic<32> = $signed({{pat_dposy[11] repeat 20}, pat_dposy}); // 12 -> 32 (signed)
                        let areax32: signed logic<32> = $signed({{reg_area_posx[10] repeat 21}, reg_area_posx}); // 11 -> 32 (signed)
                        let areay32: signed logic<32> = $signed({{reg_area_posy[10] repeat 21}, reg_area_posy}); // 11 -> 32 (signed)

                        // rect: [dpos, dpos+dsiz)
                        let rx0: signed logic<32> = patx32;
                        let ry0: signed logic<32> = paty32;
                        let rx1: signed logic<32> = patx32 + $signed({21'd0, dsizx_new}); // 0-extend then signed
                        let ry1: signed logic<32> = paty32 + $signed({21'd0, dsizy_new}); // 0-extend then signed

                        // draw area: [pos, pos+size)
                        let ax0: signed logic<32> = areax32;
                        let ay0: signed logic<32> = areay32;
                        let ax1: signed logic<32> = areax32 + $signed({21'd0, reg_area_sizx}); // size is unsigned -> 0-extend
                        let ay1: signed logic<32> = areay32 + $signed({21'd0, reg_area_sizy});


                        // frame bounds: [0, w) [0, h)
                        let fx0: signed logic<32> = 32'sd0;
                        let fy0: signed logic<32> = 32'sd0;
                        let fx1: signed logic<32> = $signed({21'd0, reg_frame_w}); // unsigned -> 0-extend then signed
                        let fy1: signed logic<32> = $signed({21'd0, reg_frame_h});

                        // intersection
                        let cx0: signed logic<32> = if rx0 <: ax0 ? ax0 : (if rx0 <: fx0 ? fx0 : rx0);
                        let cy0: signed logic<32> = if ry0 <: ay0 ? ay0 : (if ry0 <: fy0 ? fy0 : ry0);
                        let cx1: signed logic<32> = if rx1 >: ax1 ? ax1 : (if rx1 >: fx1 ? fx1 : rx1);
                        let cy1: signed logic<32> = if ry1 >: ay1 ? ay1 : (if ry1 >: fy1 ? fy1 : ry1);

                        if (cx0 >= cx1) || (cy0 >= cy1) {
                            // nothing to draw
                            state = State::fetch;
                        } else {
                            // convert to unsigned 12-bit (safe because clipped with frame [0, w/h))
                            let x0_u  : logic       <12> = cx0[11:0];
                            let x1_u  : logic       <12> = cx1[11:0];
                            let y0_u  : logic       <12> = cy0[11:0];
                            let y1_u  : logic       <12> = cy1[11:0];
                            let remx  : signed logic<32> = cx1 - cx0;
                            let remx_u: logic       <12> = remx[11:0];

                            draw_x0 = x0_u;
                            draw_x1 = x1_u;
                            draw_y0 = y0_u;
                            draw_y1 = y1_u;

                            cur_x = x0_u;
                            cur_y = y0_u;

                            // init address to (cx0, cy0)
                            addr_reg = pix_addr(reg_frame_base, reg_frame_w, x0_u, y0_u);

                            // init burst
                            burst_idx = 5'd0;
                            burst_len = min16(remx_u); // min(16, x1-x0)

                            state = State::draw;
                        }
                    }
                }
                // DRAW: stream pixels to vramctrl
                State::draw: {
                    if DRWVC_WREADY {
                        // accept 1 beat
                        let end_of_burst: logic = burst_idx == (burst_len - 5'd1);
                        let end_of_line : logic = (cur_x + 12'd1) == draw_x1;
                        let end_of_rect : logic = end_of_line && ((cur_y + 12'd1) == draw_y1);

                        // advance pixel in any case
                        addr_reg  += 32'd4;
                        cur_x     += 12'd1;
                        burst_idx += 5'd1;

                        if end_of_burst {
                            // new burst starts next
                            burst_idx = 5'd0;

                            if end_of_line {
                                // go to next line (or finish)
                                if end_of_rect {
                                    state = State::fetch;
                                } else {
                                    cur_y += 12'd1;
                                    cur_x =  draw_x0;

                                    addr_reg  = pix_addr(reg_frame_base, reg_frame_w, draw_x0, cur_y + 12'd1);
                                    burst_len = min16(draw_x1 - draw_x0);
                                    state     = State::draw;
                                }
                            } else {
                                // continue same line: remaining = x1 - (x+1)
                                burst_len = min16(draw_x1 - (cur_x + 12'd1));
                                state     = State::draw;
                            }
                        } else {
                            // stay in same burst
                            state = State::draw;
                        }
                    }
                }
                // EODL
                State::eodl_done: {
                    // drawing は State::draw に入っている間しか起きないので、
                    // ここまで到達していれば proc 側の書き込み生成は完了しているはず
                    INT   = 1'b1;
                    state = State::idle;
                }
                default: {
                    state = State::idle;
                }
            }
        }
    }
}
