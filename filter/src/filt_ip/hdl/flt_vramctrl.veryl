// ============================== flt_vramctrl.veryl (corrected v5 - beats counter & Veryl ops) ==============================
/// VRAM Control (Veryl, line-based; AXI4 32-bit/pixel)
///
/// v5 changes:
/// - Fix remaining VIP error "Expected N beats got 1" by **counting W beats explicitly** (`w_sent`)
///   and generating `WLAST` when `w_sent == aw_beats_q-1`. No reliance on `w_beats_rem`.
/// - Keep **AWLEN handshake safe** via `addr_prep`â†’`set_addr` (AWLEN stable before AWVALID).
/// - Respect Veryl syntax: `_ default`, `as <bits>`, `?:`, and `>:` / `<:` operators.
/// - READ side unchanged (RREADY=1 during burst; AR throttled by FIFO space).
pub module flt_vramctrl (
    CLK : input clock,
    ARST: input reset,
    RSTS: input reset, // synchronous-high module reset

    RESOL: input Resolution::Mode,

    // Read Address
    ARADDR : output logic<32>,
    ARVALID: output logic    ,
    ARLEN  : output logic<8> ,
    ARREADY: input  logic    ,

    // Read Data
    RDATA : input  logic<32>,
    RLAST : input  logic    ,
    RVALID: input  logic    ,
    RREADY: output logic    ,

    // Write Address
    AWADDR : output logic<32>,
    AWVALID: output logic    ,
    AWLEN  : output logic<8> ,
    AWREADY: input  logic    ,

    // Write Data
    WDATA : output logic<32>,
    WLAST : output logic    ,
    WVALID: output logic    ,
    WSTRB : output logic<4> ,
    WREADY: input  logic    ,

    // Response
    BVALID: input  logic,
    BREADY: output logic,

    // Control
    FLTRG_START  : input logic    ,
    FLTRG_VRAMSRC: input logic<32>,
    FLTRG_VRAMFRM: input logic<32>,

    // Filter I/F
    FLTPC_WDATAVLD: input logic    ,
    FLTPC_WDATA   : input logic<32>,

    FLTVC_SDATAVLD: output logic    ,
    FLTVC_SDATA   : output logic<32>,

    FLTVC_BUSY: output logic,
    FLTVC_INT : output logic,
) {
    let rst: '_ default reset_sync_high = ARST | RSTS;

    const BLEN        : u32 = 16; // beats per burst (<=256)
    const FIFO_DEPTH  : u32 = 2048; // 2048 to cover SXGA
    const SRC_SAFE_GAP: u32 = 2; // headroom for filter latency

    // ---------------- geometry ----------------
    var width : logic<16>;
    var height: logic<16>;
    always_comb {
        case RESOL {
            Resolution::Mode::vga: {
                width  = 16'd640;
                height = 16'd480;
            }
            Resolution::Mode::xga: {
                width  = 16'd1024;
                height = 16'd768;
            }
            Resolution::Mode::sxga: {
                width  = 16'd1280;
                height = 16'd1024;
            }
            default: {
                width  = 16'd640;
                height = 16'd480;
            }
        }
    }
    let line_bytes: logic<32> = {width, 2'b00};

    // ---------------- line manager ----------------
    enum LineState {
        idle,
        read,
        write,
        done,
    }
    var line_state: LineState    ;
    var line_index: logic    <16>;

    var start_q: logic;
    always_ff {
        if_reset {
            start_q = 1'b0;
        } else {
            start_q = FLTRG_START;
        }
    }
    let start_pulse: logic = FLTRG_START & ~start_q;

    var busy_d    : logic;
    assign FLTVC_BUSY = (line_state != LineState::idle);

    var rd_line_done: logic;

    always_ff {
        if_reset {
            line_state = LineState::idle;
            line_index = 16'd0;
            busy_d     = 1'b0;
            FLTVC_INT  = 1'b0;
        } else {
            busy_d = FLTVC_BUSY;
            case line_state {
                LineState::idle: if start_pulse {
                    line_state = LineState::read;
                    line_index = 16'd0;
                }
                LineState::read: if rd_line_done {
                    line_state = LineState::write;
                }
                LineState::write: if wr_line_done {
                    if line_index == height - 1 {
                        line_state = LineState::done;
                    } else {
                        line_index = line_index + 1;
                        line_state = LineState::read;
                    }
                }
                LineState::done: line_state = LineState::idle;
            }
            FLTVC_INT = (busy_d == 1'b1) && (FLTVC_BUSY == 1'b0);
        }
    }

    // ---------------- FIFOs & filter wiring ----------------
    var src_dout : logic<32>;
    var src_empty: logic    ;
    var src_full : logic    ;
    var src_valid: logic    ;
    var src_rd_en: logic    ;
    var src_wr_en: logic    ;
    var src_count: logic<12>;

    inst u_fifo_src: $sv::fifo_32in32out_2048depth (
        clk       : CLK      ,
        din       : RDATA    ,
        rd_en     : src_rd_en,
        rst       : rst      ,
        wr_en     : src_wr_en,
        dout      : src_dout ,
        empty     : src_empty,
        full      : src_full ,
        overflow  : _        ,
        valid     : src_valid,
        underflow : _        ,
        data_count: src_count,
    );

    var wrt_dout : logic<32>;
    var wrt_empty: logic    ;
    var wrt_full : logic    ;
    var wrt_valid: logic    ;
    var wrt_rd_en: logic    ;
    var wrt_wr_en: logic    ;
    var wrt_count: logic<12>;

    inst u_fifo_wrt: $sv::fifo_32in32out_2048depth (
        clk       : CLK        ,
        din       : FLTPC_WDATA,
        rd_en     : wrt_rd_en  ,
        rst       : rst        ,
        wr_en     : wrt_wr_en  ,
        dout      : wrt_dout   ,
        empty     : wrt_empty  ,
        full      : wrt_full   ,
        overflow  : _          ,
        valid     : wrt_valid  ,
        underflow : _          ,
        data_count: wrt_count  ,
    );

    assign FLTVC_SDATA    = src_dout;
    assign FLTVC_SDATAVLD = src_valid; // dout valid = 1-cycle after rd_en
    assign src_rd_en      = (!src_empty); // always drain when data exists
    assign wrt_wr_en      = FLTPC_WDATAVLD;

    // ---------------- READ FSM (AR/R) ----------------
    enum RState {
        idle,
        set_addr,
        read,
        wait,
    }
    var r_state    : RState    ;
    var r_addr     : logic <32>;
    var r_line_rem : logic <16>;
    var r_beats_rem: logic <8> ;
    var r_inflight : logic     ;

    var want8       : logic<8> ;
    var need_space32: logic<32>;
    var avail32     : logic<32>;
    var space_ok    : logic    ;

    always_comb {
        let blen8       : logic<8> = BLEN as 8;
        want8        = if r_line_rem >: (BLEN as 16) ? blen8 : (r_line_rem as 8);
        need_space32 = (want8 as 32) + (SRC_SAFE_GAP as 32);
        avail32      = (FIFO_DEPTH as 32) - (src_count as 32);
        space_ok     = (avail32 >: need_space32) || (avail32 == need_space32);
        rd_line_done = (r_line_rem == 16'd0) && (r_inflight == 1'b0) && (r_beats_rem == 8'd0);
    }

    always_ff {
        if_reset {
            ARADDR      = 32'd0;
            ARLEN       = 8'd0;
            ARVALID     = 1'b0;
            RREADY      = 1'b0;
            r_state     = RState::idle;
            r_addr      = 32'd0;
            r_line_rem  = 16'd0;
            r_beats_rem = 8'd0;
            r_inflight  = 1'b0;
            src_wr_en   = 1'b0;
        } else {
            case r_state {
                RState::idle: {
                    RREADY = 1'b0;
                    if line_state == LineState::read {
                        r_addr      = FLTRG_VRAMSRC + (line_bytes * line_index);
                        r_line_rem  = width;
                        r_beats_rem = 8'd0;
                        r_inflight  = 1'b0;
                        r_state     = RState::set_addr;
                    }
                }
                RState::set_addr: {
                    if !ARVALID && !r_inflight && (r_line_rem != 0) && space_ok {
                        ARADDR  = r_addr;
                        ARLEN   = want8 - 1;
                        ARVALID = 1'b1;
                    }
                    if ARVALID && ARREADY {
                        ARVALID     = 1'b0;
                        r_inflight  = 1'b1;
                        r_beats_rem = want8; // use combo-latched want8
                        r_addr      = r_addr + ((want8 as 32) << 2);
                        r_line_rem  = r_line_rem - (want8 as 16);
                        r_state     = RState::read;
                    }
                }
                RState::read: {
                    RREADY = 1'b1; // keep progress
                    if RVALID && RREADY {
                        r_beats_rem = r_beats_rem - 1;
                        src_wr_en   = 1'b1;
                        if RLAST || (r_beats_rem == 8'd1) {
                            r_inflight = 1'b0;
                            r_state    = if (r_line_rem != 0) ? RState::set_addr : RState::wait;
                        }
                    }
                }
                RState::wait: {
                    RREADY = 1'b0;
                    if line_state != LineState::read {
                        r_state = RState::idle;
                    }
                }
            }
            if !(RVALID && RREADY) {
                src_wr_en = 1'b0;
            }
        }
    }

    // ---------------- WRITE FSM (AW/W/B) ----------------
    enum WState {
        idle,
        addr_prep,
        set_addr,
        write,
        wait,
    }
    var w_state     : WState    ;
    var w_addr      : logic <32>;
    var w_line_rem  : logic <16>;
    var w_on_txn    : logic     ;
    var end_of_burst: logic     ;

    // latched beats count for the upcoming burst
    var aw_beats_q: logic<8>;
    // explicit sent-beat counter within current burst
    var w_sent        : logic<8>;
    var w_burst_active: logic   ;

    var wdata_q      : logic<32>;
    var wdata_q_valid: logic    ;

    assign WSTRB  = 4'hF;
    assign BREADY = (w_state == WState::wait);

    var wwant : logic<8>;
    var wavail: logic<8>;

    always_comb {
        let blen8 : logic<8> = BLEN as 8;
        wwant  = if w_line_rem >: (BLEN as 16) ? blen8 : (w_line_rem as 8);
        wavail = if (wrt_count[7:0] <: wwant) ? wrt_count[7:0] : wwant;
    }

    always_ff {
        if_reset {
            w_state        = WState::idle;
            AWADDR         = 32'd0;
            AWLEN          = 8'd0;
            AWVALID        = 1'b0;
            WDATA          = 32'd0;
            WLAST          = 1'b0;
            WVALID         = 1'b0;
            w_addr         = 32'd0;
            w_line_rem     = 16'd0;
            w_on_txn       = 1'b0;
            end_of_burst   = 1'b0;
            wrt_rd_en      = 1'b0;
            wdata_q        = 32'd0;
            wdata_q_valid  = 1'b0;
            aw_beats_q     = 8'd0;
            w_sent         = 8'd0;
            w_burst_active = 1'b0;
        } else {
            wrt_rd_en = 1'b0;
            WLAST     = 1'b0; // default

            case w_state {
                WState::idle: {
                    WVALID         = 1'b0;
                    end_of_burst   = 1'b0;
                    w_on_txn       = 1'b0;
                    wdata_q_valid  = 1'b0;
                    w_burst_active = 1'b0;
                    w_sent         = 8'd0;
                    if line_state == LineState::write {
                        w_addr     = FLTRG_VRAMFRM + (line_bytes * line_index);
                        w_line_rem = width;
                        w_state    = WState::addr_prep;
                    }
                }
                WState::addr_prep: {
                    if (w_line_rem != 0) && (wrt_count != 12'd0) {
                        if (wavail != 8'd0) {
                            aw_beats_q = wavail; // latch beats count
                            AWADDR     = w_addr;
                            AWLEN      = wavail - 1; // beats-1
                            w_state    = WState::set_addr; // next: assert AWVALID
                        }
                    }
                }
                WState::set_addr: {
                    AWVALID = 1'b1; // AWLEN stable for 1 cycle before assertion
                    if AWVALID && AWREADY {
                        AWVALID        = 1'b0;
                        w_on_txn       = 1'b1;
                        w_burst_active = 1'b1;
                        w_sent         = 8'd0; // start counting
                        w_addr         = w_addr + ((aw_beats_q as 32) << 2);
                        w_line_rem     = w_line_rem - (aw_beats_q as 16);
                        wrt_rd_en      = 1'b1; // prefetch first beat
                        w_state        = WState::write;
                    }
                }
                WState::write: {
                    if !wdata_q_valid && wrt_valid {
                        wdata_q       = wrt_dout;
                        wdata_q_valid = 1'b1;
                    }

                    // WLAST when next accepted beat will be the last of this burst
                    let last_cond: logic = (w_burst_active == 1'b1) && (wdata_q_valid == 1'b1) && (w_sent == (aw_beats_q - 1));
                    WDATA     = wdata_q;
                    WVALID    = (w_burst_active == 1'b1) && (wdata_q_valid == 1'b1) && (end_of_burst == 1'b0);
                    WLAST     = last_cond;

                    if WVALID && WREADY {
                        // consume this beat
                        wdata_q_valid = 1'b0;
                        // prefetch next unless this beat was the last
                        wrt_rd_en = !WLAST;
                        // increment sent counter *after* using last_cond
                        if !WLAST {
                            w_sent = w_sent + 1;
                        } else {
                            end_of_burst   = 1'b1; // wait for BRESP
                            w_on_txn       = 1'b0;
                            w_burst_active = 1'b0;
                            w_state        = WState::wait;
                        }
                    }
                }
                WState::wait: {
                    if BVALID && BREADY {
                        end_of_burst = 1'b0;
                        if (w_line_rem == 0) && (wrt_count == 0) && (wdata_q_valid == 1'b0) {
                            w_state = WState::idle; // line complete
                        } else {
                            w_state = WState::addr_prep; // next burst
                        }
                    }
                }
            }
        }
    }

    // write-line done when FSM returns idle while line_state=write
    let wr_line_done: logic = (w_state == WState::idle) && (line_state == LineState::write);
}
