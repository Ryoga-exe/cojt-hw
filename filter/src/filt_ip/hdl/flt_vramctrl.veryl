/// VRAM Control for filter
pub module flt_vramctrl (
    CLK : input clock,
    ARST: input reset,
    RSTS: input reset, // module reset (High)

    RESOL: input Resolution::Mode,

    // Read Address
    ARADDR : output logic<32>,
    ARVALID: output logic    ,
    ARLEN  : output logic<8> ,
    ARREADY: input  logic    ,

    // Read Data
    RDATA : input  logic<32>,
    RLAST : input  logic    ,
    RVALID: input  logic    ,
    RREADY: output logic    ,

    // Write Address
    AWADDR : output logic<32>,
    AWVALID: output logic    ,
    AWLEN  : output logic<8> ,
    AWREADY: input  logic    ,

    // Write Data
    WDATA : output logic<32>,
    WLAST : output logic    ,
    WVALID: output logic    ,
    WSTRB : output logic<4> ,
    WREADY: input  logic    ,

    // Response
    BVALID: input  logic,
    BREADY: output logic,

    FLTRG_START  : input logic    ,
    FLTRG_VRAMSRC: input logic<32>,
    FLTRG_VRAMFRM: input logic<32>,

    // from filter
    FLTPC_WDATAVLD: input logic    ,
    FLTPC_WDATA   : input logic<32>,

    // to filter
    FLTVC_SDATAVLD: output logic    ,
    FLTVC_SDATA   : output logic<32>,

    FLTVC_BUSY: output logic,
    FLTVC_INT : output logic,
) {
    // 内部リセット（同期 High）
    let rst: '_ default reset_sync_high = ARST | RSTS;

    const BLEN      : u32 = 16; // 1 バーストあたりのビート数 (最大)
    const FIFO_DEPTH: u32 = 1024; // src/wrt FIFO の深さ（1 ライン分）

    // 解像度 → width / height
    var width : logic<16>;
    var height: logic<16>;

    always_comb {
        case RESOL {
            Resolution::Mode::vga: {
                width  = 16'd640;
                height = 16'd480;
            }
            Resolution::Mode::xga: {
                width  = 16'd1024;
                height = 16'd768;
            }
            Resolution::Mode::sxga: {
                width  = 16'd1280;
                height = 16'd1024;
            }
            default: {
                width  = 16'd640;
                height = 16'd480;
            }
        }
    }

    // 1 ラインのバイト数 = width * 4
    let line_bytes: logic<32> = (width as 32) << 2;

    //======================================================================
    // フレーム制御 FSM
    //======================================================================
    enum FrameState {
        idle,
        rd_line,
        wr_line,
        done,
    }

    var frame_state: FrameState    ;
    var line_index : logic     <16>;

    // FLTRG_START の立ち上がり検出
    var start_q    : logic;
    let start_pulse: logic = FLTRG_START & ~start_q;

    always_ff {
        if_reset {
            start_q = 1'b0;
        } else {
            start_q = FLTRG_START;
        }
    }

    // BUSY / INT
    assign FLTVC_BUSY = frame_state != FrameState::idle;

    var busy_d: logic;

    // 読み出し / 書き込みライン完了フラグ（1 サイクルパルス）
    var rd_line_done: logic;
    var wr_line_done: logic;

    always_ff {
        if_reset {
            frame_state = FrameState::idle;
            line_index  = 16'd0;
            busy_d      = 1'b0;
            FLTVC_INT   = 1'b0;
        } else {
            busy_d    = FLTVC_BUSY;
            FLTVC_INT = 1'b0;

            case frame_state {
                FrameState::idle: {
                    if start_pulse {
                        frame_state = FrameState::rd_line;
                        line_index  = 16'd0;
                    }
                }
                FrameState::rd_line: {
                    if rd_line_done == 1'b1 {
                        frame_state = FrameState::wr_line;
                    }
                }
                FrameState::wr_line: {
                    if wr_line_done == 1'b1 {
                        if line_index == (height - 16'd1) {
                            frame_state = FrameState::done;
                        } else {
                            line_index  = line_index + 16'd1;
                            frame_state = FrameState::rd_line;
                        }
                    }
                }
                FrameState::done: {
                    frame_state = FrameState::idle;
                }
            }

            // BUSY の立下りで INT パルス
            if (busy_d == 1'b1) && (FLTVC_BUSY == 1'b0) {
                FLTVC_INT = 1'b1;
            }
        }
    }

    //======================================================================
    // FIFO: src (R → filter), wrt (filter → W)
    //======================================================================
    // src FIFO
    var src_dout : logic<32>;
    var src_empty: logic    ;
    var src_full : logic    ;
    var src_valid: logic    ;
    var src_count: logic<11>;
    var src_rd_en: logic    ;
    var src_wr_en: logic    ;

    inst u_fifo_src: $sv::fifo_32in32out_2048depth (
        clk       : CLK      ,
        din       : RDATA    ,
        rd_en     : src_rd_en,
        rst       : rst      ,
        wr_en     : src_wr_en,
        dout      : src_dout ,
        empty     : src_empty,
        full      : src_full ,
        overflow  : _        ,
        valid     : src_valid,
        underflow : _        ,
        data_count: src_count,
    );

    // wrt FIFO
    var wrt_dout : logic<32>;
    var wrt_empty: logic    ;
    var wrt_full : logic    ;
    var wrt_valid: logic    ;
    var wrt_count: logic<11>;
    var wrt_rd_en: logic    ;
    var wrt_wr_en: logic    ;

    inst u_fifo_wrt: $sv::fifo_32in32out_2048depth (
        clk       : CLK        ,
        din       : FLTPC_WDATA,
        rd_en     : wrt_rd_en  ,
        rst       : rst        ,
        wr_en     : wrt_wr_en  ,
        dout      : wrt_dout   ,
        empty     : wrt_empty  ,
        full      : wrt_full   ,
        overflow  : _          ,
        valid     : wrt_valid  ,
        underflow : _          ,
        data_count: wrt_count  ,
    );

    // filter への入力
    assign FLTVC_SDATA    = src_dout;
    assign FLTVC_SDATAVLD = src_valid;

    // filter からの出力は常に wrt FIFO へ
    assign wrt_wr_en = FLTPC_WDATAVLD;

    // src FIFO からの read: rd_line 期間だけ
    assign src_rd_en = (frame_state == FrameState::rd_line) && (src_empty == 1'b0);

    //======================================================================
    // AXI Read チャネル FSM
    //======================================================================
    enum RState {
        idle,
        addr,
        data,
    }

    var r_state    : RState    ;
    var r_addr     : logic <32>;
    var r_line_rem : logic <16>; // 残りピクセル数（ライン内）
    var r_burst_rem: logic <8> ; // 現在バーストの残りビート数
    var r_active   : logic     ; // バースト発行済み (AR->R 待ち)
    var r_burst_len: logic <8> ; // 今回バースト長

    always_ff {
        if_reset {
            ARADDR  = 32'd0;
            ARLEN   = 8'd0;
            ARVALID = 1'b0;
            RREADY  = 1'b0;

            r_state      = RState::idle;
            r_addr       = 32'd0;
            r_line_rem   = 16'd0;
            r_burst_rem  = 8'd0;
            r_active     = 1'b0;
            r_burst_len  = 8'd0;
            src_wr_en    = 1'b0;
            rd_line_done = 1'b0;
        } else {
            // デフォルト
            src_wr_en    = 1'b0;
            rd_line_done = 1'b0;

            case r_state {
                RState::idle: {
                    RREADY      = 1'b0;
                    ARVALID     = 1'b0;
                    r_active    = 1'b0;
                    r_burst_rem = 8'd0;

                    // ライン読み出し開始
                    if frame_state == FrameState::rd_line {
                        r_addr     = FLTRG_VRAMSRC + (line_bytes * (line_index as 32));
                        r_line_rem = width;
                        r_state    = RState::addr;
                    }
                }

                RState::addr: {
                    RREADY = 1'b0;

                    // 残りピクセルがあり、かつ未バースト中、かつ FIFO がフルでなければ AR を発行
                    if (r_active == 1'b0) && (r_line_rem != 16'd0) && (src_full == 1'b0) {

                        if r_line_rem >: (BLEN as 16) {
                            r_burst_len = BLEN as 8;
                        } else {
                            r_burst_len = r_line_rem[7:0];
                        }

                        ARADDR  = r_addr;
                        ARLEN   = r_burst_len - 8'd1;
                        ARVALID = 1'b1;

                        if (ARREADY == 1'b1) {
                            // 即座にハンドシェイク成立
                            ARVALID     = 1'b0;
                            r_active    = 1'b1;
                            r_burst_rem = r_burst_len;
                            r_addr      = r_addr + ((r_burst_len as 32) << 2);
                            r_line_rem  = r_line_rem - r_burst_len as 16;
                            r_state     = RState::data;
                        }
                    }
                }

                RState::data: {
                    // FIFO がフルでない限り R データを受け取る
                    RREADY = (src_full == 1'b0);

                    if (RVALID == 1'b1) && (RREADY == 1'b1) {
                        // 1 ビート受信 → FIFO 書き込み
                        src_wr_en = 1'b1;

                        if r_burst_rem != 8'd0 {
                            r_burst_rem = r_burst_rem - 8'd1;
                        }

                        // バースト終了判定
                        if (RLAST == 1'b1) || (r_burst_rem == 8'd1) {
                            r_active = 1'b0;

                            if (r_line_rem == 16'd0) {
                                // ライン分読み切り
                                rd_line_done = 1'b1;
                                r_state      = RState::idle;
                                RREADY       = 1'b0;
                            } else {
                                // 次のバーストへ
                                r_state = RState::addr;
                            }
                        }
                    }
                }
            }

            // frame_state が rd_line 以外になったときの保険
            if (frame_state != FrameState::rd_line) && (r_state != RState::idle) {
                RREADY   = 1'b0;
                ARVALID  = 1'b0;
                r_active = 1'b0;
                r_state  = RState::idle;
            }
        }
    }

    //======================================================================
    // AXI Write チャネル FSM
    //======================================================================
    enum WState {
        idle,
        addr,
        data,
        resp,
    }

    var w_state    : WState    ;
    var w_addr     : logic <32>;
    var w_line_rem : logic <16>;
    var w_burst_rem: logic <8> ;
    var w_burst_len: logic <8> ;
    var w_active   : logic     ;

    var w_data_reg : logic<32>;
    var w_have_data: logic    ;

    always_comb {
        // 常にフルストローブ
        WSTRB = 4'hF;
    }

    always_ff {
        if_reset {
            AWADDR  = 32'd0;
            AWLEN   = 8'd0;
            AWVALID = 1'b0;

            WDATA  = 32'd0;
            WLAST  = 1'b0;
            WVALID = 1'b0;

            BREADY = 1'b0;

            w_state     = WState::idle;
            w_addr      = 32'd0;
            w_line_rem  = 16'd0;
            w_burst_rem = 8'd0;
            w_burst_len = 8'd0;
            w_active    = 1'b0;

            w_data_reg  = 32'd0;
            w_have_data = 1'b0;

            wrt_rd_en    = 1'b0;
            wr_line_done = 1'b0;
        } else {
            // デフォルト
            wrt_rd_en    = 1'b0;
            wr_line_done = 1'b0;

            case w_state {
                WState::idle: {
                    AWVALID     = 1'b0;
                    WVALID      = 1'b0;
                    WLAST       = 1'b0;
                    BREADY      = 1'b0;
                    w_active    = 1'b0;
                    w_burst_rem = 8'd0;
                    w_burst_len = 8'd0;
                    w_have_data = 1'b0;

                    if frame_state == FrameState::wr_line {
                        // このラインの先頭アドレスを計算
                        w_addr     = FLTRG_VRAMFRM + (line_bytes * (line_index as 32));
                        w_line_rem = width;
                        w_state    = WState::addr;
                    }
                }

                WState::addr: {
                    WVALID = 1'b0;
                    WLAST  = 1'b0;
                    BREADY = 1'b0;

                    // バースト未進行かつ残りピクセルがあり、FIFO に何か入っていれば AW を出す
                    if (w_active == 1'b0) && (w_line_rem != 16'd0) && (wrt_empty == 1'b0) {

                        if w_line_rem >: BLEN as 16 {
                            w_burst_len = BLEN as 8;
                        } else {
                            w_burst_len = w_line_rem[7:0];
                        }

                        AWADDR  = w_addr;
                        AWLEN   = w_burst_len - 8'd1;
                        AWVALID = 1'b1;

                        if (AWREADY == 1'b1) {
                            // 即座にアドレスハンドシェイク成立
                            AWVALID     = 1'b0;
                            w_active    = 1'b1;
                            w_burst_rem = w_burst_len;
                            w_addr      = w_addr + ((w_burst_len as 32) << 2);
                            w_line_rem  = w_line_rem - w_burst_len as 16;
                            w_state     = WState::data;
                        }
                    }
                }

                WState::data: {
                    BREADY = 1'b0;

                    // まだ送るビートが残っている
                    if w_burst_rem != 8'd0 {
                        // 送信用データをまだ持っていないなら FIFO からロード
                        if w_have_data == 1'b0 {
                            // まず rd_en で新しいデータを要求
                            if (wrt_valid == 1'b1) {
                                w_data_reg  = wrt_dout;
                                w_have_data = 1'b1;
                            } else if (wrt_empty == 1'b0) {
                                wrt_rd_en = 1'b1;
                            }
                        }

                        // データを保持していれば W チャネルに出す
                        WDATA  = w_data_reg;
                        WVALID = w_have_data;
                        WLAST  = (w_burst_rem == 8'd1) && (w_have_data == 1'b1);

                        if (WVALID == 1'b1) && (WREADY == 1'b1) {
                            // 1 ビート送信完了
                            w_have_data = 1'b0;

                            if w_burst_rem != 8'd0 {
                                w_burst_rem = w_burst_rem - 8'd1;
                            }

                            if w_burst_rem == 8'd1 {
                                // 今送ったビートが WLAST
                                w_active = 1'b0;
                                WVALID   = 1'b0;
                                WLAST    = 1'b0;
                                w_state  = WState::resp;
                            } else {
                                // 次のデータを FIFO から要求
                                if wrt_empty == 1'b0 {
                                    wrt_rd_en = 1'b1;
                                }
                            }
                        }
                    } else {
                        // 送るものがなくなったらレスポンス待ちへ
                        WVALID  = 1'b0;
                        WLAST   = 1'b0;
                        w_state = WState::resp;
                    }
                }

                WState::resp: {
                    WVALID = 1'b0;
                    WLAST  = 1'b0;
                    BREADY = 1'b1;

                    if (BVALID == 1'b1) && (BREADY == 1'b1) {
                        BREADY = 1'b0;

                        if (w_line_rem == 16'd0) && (w_active == 1'b0) {
                            // このラインの書き込み完了
                            wr_line_done = 1'b1;
                            w_state      = WState::idle;
                        } else {
                            // まだこのラインに送るデータが残っているので次のバーストへ
                            w_state = WState::addr;
                        }
                    }
                }
            }

            // frame_state が wr_line 以外になったら保険で idle へ
            if frame_state != FrameState::wr_line {
                AWVALID  = 1'b0;
                WVALID   = 1'b0;
                WLAST    = 1'b0;
                BREADY   = 1'b0;
                w_active = 1'b0;
                w_state  = WState::idle;
            }
        }
    }
}
