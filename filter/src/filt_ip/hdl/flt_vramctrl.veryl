/// VRAM Control (Veryl, frame-based; AXI4 32-bit/pixel)
///
/// - FLTRG_START の立ち上がりで 1 フレーム処理開始
/// - フレーム中は VRAM_SRC から width*height ピクセル読み出して src FIFO へ
/// - フィルタが wrt FIFO に書いたものを同じ数だけ VRAM_FRM に書き戻す
/// - 処理完了で FLTVC_BUSY を 0 にし、その立ち下がりで FLTVC_INT を 1 パルス
pub module flt_vramctrl (
    CLK : input clock,
    ARST: input reset,
    RSTS: input reset, // module reset (High)

    RESOL: input Resolution::Mode,

    // Read Address
    ARADDR : output logic<32>,
    ARVALID: output logic    ,
    ARLEN  : output logic<8> ,
    ARREADY: input  logic    ,

    // Read Data
    RDATA : input  logic<32>,
    RLAST : input  logic    ,
    RVALID: input  logic    ,
    RREADY: output logic    ,

    // Write Address
    AWADDR : output logic<32>,
    AWVALID: output logic    ,
    AWLEN  : output logic<8> ,
    AWREADY: input  logic    ,

    // Write Data
    WDATA : output logic<32>,
    WLAST : output logic    ,
    WVALID: output logic    ,
    WSTRB : output logic<4> ,
    WREADY: input  logic    ,

    // Response
    BVALID: input  logic,
    BREADY: output logic,

    // Control
    FLTRG_START  : input logic    ,
    FLTRG_VRAMSRC: input logic<32>,
    FLTRG_VRAMFRM: input logic<32>,

    // Filter I/F
    FLTPC_WDATAVLD: input logic    ,
    FLTPC_WDATA   : input logic<32>,

    FLTVC_SDATAVLD: output logic    ,
    FLTVC_SDATA   : output logic<32>,

    FLTVC_BUSY: output logic,
    FLTVC_INT : output logic,
) {
    // FIFO のリセットだけ共通線にする
    let rst_fifo: logic = ARST | RSTS;

    const BLEN        : u32 = 16; // READ側の最大バースト長
    const FIFO_DEPTH  : u32 = 2048; // src / wrt FIFO の深さ
    const SRC_SAFE_GAP: u32 = 2; // 読み FIFO の安全マージン

    // ---------------- geometry ----------------
    var width : logic<16>;
    var height: logic<16>;
    always_comb {
        case RESOL {
            Resolution::Mode::vga: {
                width  = 16'd640;
                height = 16'd480;
            }
            Resolution::Mode::xga: {
                width  = 16'd1024;
                height = 16'd768;
            }
            Resolution::Mode::sxga: {
                width  = 16'd1280;
                height = 16'd1024;
            }
            default: {
                width  = 16'd640;
                height = 16'd480;
            }
        }
    }

    // フレーム中のピクセル数
    let frame_pixels: logic<32> = (width as 32) * (height as 32);

    // ---------------- FIFOs & filter wiring ----------------
    // src FIFO (R -> PROC)
    var src_dout : logic<32>;
    var src_empty: logic    ;
    var src_full : logic    ;
    var src_valid: logic    ;
    var src_rd_en: logic    ;
    var src_wr_en: logic    ;
    var src_count: logic<12>;

    inst u_fifo_src: $sv::fifo_32in32out_2048depth (
        clk       : CLK      ,
        din       : RDATA    ,
        rd_en     : src_rd_en,
        rst       : rst_fifo ,
        wr_en     : src_wr_en,
        dout      : src_dout ,
        empty     : src_empty,
        full      : src_full ,
        overflow  : _        ,
        valid     : src_valid,
        underflow : _        ,
        data_count: src_count,
    );

    // wrt FIFO (PROC -> W)
    var wrt_dout : logic<32>;
    var wrt_empty: logic    ;
    var wrt_full : logic    ;
    var wrt_valid: logic    ;
    var wrt_rd_en: logic    ;
    var wrt_wr_en: logic    ;
    var wrt_count: logic<12>;

    inst u_fifo_wrt: $sv::fifo_32in32out_2048depth (
        clk       : CLK        ,
        din       : FLTPC_WDATA,
        rd_en     : wrt_rd_en  ,
        rst       : rst_fifo   ,
        wr_en     : wrt_wr_en  ,
        dout      : wrt_dout   ,
        empty     : wrt_empty  ,
        full      : wrt_full   ,
        overflow  : _          ,
        valid     : wrt_valid  ,
        underflow : _          ,
        data_count: wrt_count  ,
    );

    assign FLTVC_SDATA    = src_dout;
    assign FLTVC_SDATAVLD = src_valid; // dout が有効なサイクル
    assign src_rd_en      = (!src_empty); // データがある限りひたすらドレイン
    assign wrt_wr_en      = FLTPC_WDATAVLD; // フィルタ出力を FIFO に格納

    // ---------------- フレーム全体の状態管理 ----------------
    var frame_active  : logic; // 1 の間は 1 フレーム処理中
    var frame_active_d: logic;
    var FLTVC_INT_r   : logic;

    assign FLTVC_BUSY = frame_active;
    assign FLTVC_INT  = FLTVC_INT_r;

    // このサイクルに新しいフレームを開始するかどうか
    let start_frame: logic = FLTRG_START && (frame_active == 1'b0);

    // 後で read / write FSM から計算される
    var rd_done: logic;
    var wr_done: logic;

    always_ff {
        if ARST || RSTS {
            frame_active   = 1'b0;
            frame_active_d = 1'b0;
            FLTVC_INT_r    = 1'b0;
        } else {
            frame_active_d = frame_active;
            FLTVC_INT_r    = 1'b0;

            if !frame_active {
                // 新しいフレーム開始トリガ
                if FLTRG_START {
                    frame_active = 1'b1;
                }
            } else {
                // 読み書きが両方完了したらフレーム終了
                if rd_done && wr_done {
                    frame_active = 1'b0;
                }
            }

            // BUSY の立下がりで INT 1 パルス
            if frame_active_d && !frame_active {
                FLTVC_INT_r = 1'b1;
            }
        }
    }

    // ---------------- READ (AR/R) FSM ----------------
    enum RState {
        idle,
        issue,
        data,
    }
    var r_state     : RState    ;
    var r_addr      : logic <32>; // 次の ARADDR
    var r_pixels_rem: logic <32>; // 残りピクセル数
    var r_beats_rem : logic <8> ; // 現バーストの残りビート数

    // バースト長決定 & FIFO 空きチェック用
    var r_want    : logic<8>;
    var r_space_ok: logic   ;

    always_comb {
        // 残りピクセル数から、今回のバースト長 r_want を決める
        let blen8: logic<8>  = BLEN as 8;
        let rem16: logic<16> = r_pixels_rem[15:0];

        if r_pixels_rem == 32'd0 {
            r_want = 8'd0;
        } else if rem16 >: (BLEN as 16) {
            r_want = blen8;
        } else {
            r_want = rem16[7:0];
        }

        // FIFO の空きが「r_want + SRC_SAFE_GAP」以上あるか
        let need_space32: logic<32> = (r_want as 32) + (SRC_SAFE_GAP as 32);
        let avail32     : logic<32> = (FIFO_DEPTH as 32) - (src_count as 32);
        let enough      : logic     = (avail32 >: need_space32) || (avail32 == need_space32);

        r_space_ok = (r_want != 8'd0) && enough;

        // 読み完了判定（フレーム中かどうかは frame_active で見ている）
        rd_done = (r_pixels_rem == 32'd0) && (r_state == RState::idle);
    }

    always_ff {
        if ARST || RSTS {
            ARADDR       = 32'd0;
            ARLEN        = 8'd0;
            ARVALID      = 1'b0;
            RREADY       = 1'b0;
            r_state      = RState::idle;
            r_addr       = 32'd0;
            r_pixels_rem = 32'd0;
            r_beats_rem  = 8'd0;
            src_wr_en    = 1'b0;
        } else {
            // デフォルト
            src_wr_en = 1'b0;

            // 新しいフレーム開始時にレジスタ初期化
            if start_frame {
                r_state      = RState::idle;
                r_addr       = FLTRG_VRAMSRC;
                r_pixels_rem = frame_pixels;
                r_beats_rem  = 8'd0;
                ARVALID      = 1'b0;
                RREADY       = 1'b0;
            }

            case r_state {
                RState::idle: {
                    RREADY = 1'b0;
                    // フレーム中 & まだ読むピクセルが残っていて FIFO に空きがあるなら AR を発行
                    if frame_active && !rd_done && r_space_ok {
                        ARADDR      = r_addr;
                        ARLEN       = r_want - 1; // beats - 1
                        ARVALID     = 1'b1;
                        r_beats_rem = r_want;
                        r_state     = RState::issue;
                    }
                }

                RState::issue: {
                    RREADY = 1'b0;
                    // ARVALID は ARREADY が来るまで保持
                    if ARVALID && ARREADY {
                        ARVALID = 1'b0;
                        // このバーストで r_want ピクセル読む
                        r_pixels_rem = r_pixels_rem - (r_want as 32);
                        r_addr       = r_addr + ((r_want as 32) << 2);
                        r_state      = RState::data;
                    }
                }

                RState::data: {
                    // バースト中は前進を止めない
                    RREADY = 1'b1;
                    if RVALID && RREADY {
                        src_wr_en   = 1'b1; // FIFO へ 1 ワード書く
                        r_beats_rem = r_beats_rem - 1;

                        // RLAST か、カウンタ的に最後の 1 拍ならバースト終了
                        if RLAST || (r_beats_rem == 8'd1) {
                            RREADY  = 1'b0;
                            r_state = RState::idle; // 次の AR は idle から
                        }
                    }
                }
            }
        }
    }

    // ---------------- WRITE (AW/W/B) FSM ----------------
    //
    // 書き込みは「1 ビート固定バースト」で簡略化：
    //   - AWLEN = 0
    //   - AW 発行 → W を 1 拍出して WLAST=1 → BRESP 待ち
    enum WState {
        idle,
        addr,
        data,
        wait,
    }
    var w_state     : WState    ;
    var w_addr      : logic <32>;
    var w_pixels_rem: logic <32>;

    // W チャネル出力レジスタ（WVALID=1 の間は WREADY=0 でも絶対に変えない）
    var WDATA_r : logic<32>;
    var WLAST_r : logic    ;
    var WVALID_r: logic    ;

    assign WDATA  = WDATA_r;
    assign WLAST  = WLAST_r;
    assign WVALID = WVALID_r;
    assign WSTRB  = 4'hF;
    assign BREADY = (w_state == WState::wait);

    always_comb {
        // 書き込み完了判定
        wr_done = (w_pixels_rem == 32'd0) && (w_state == WState::idle);
    }

    always_ff {
        if ARST || RSTS {
            w_state      = WState::idle;
            AWADDR       = 32'd0;
            AWLEN        = 8'd0;
            AWVALID      = 1'b0;
            w_addr       = 32'd0;
            w_pixels_rem = 32'd0;

            WDATA_r  = 32'd0;
            WLAST_r  = 1'b0;
            WVALID_r = 1'b0;

            wrt_rd_en = 1'b0;
        } else {
            // デフォルト
            wrt_rd_en = 1'b0;

            // 新しいフレーム開始時にレジスタ初期化
            if start_frame {
                w_state      = WState::idle;
                AWVALID      = 1'b0;
                w_addr       = FLTRG_VRAMFRM;
                w_pixels_rem = frame_pixels;
                WDATA_r      = 32'd0;
                WLAST_r      = 1'b0;
                WVALID_r     = 1'b0;
            }

            case w_state {
                WState::idle: {
                    // idle 中は W 出力をクリアしておく
                    if !frame_active {
                        WVALID_r = 1'b0;
                        WLAST_r  = 1'b0;
                    }

                    if frame_active && (w_pixels_rem != 32'd0) {
                        w_state = WState::addr;
                    }
                }

                WState::addr: {
                    // 書き出すピクセルが残っていて、wrt FIFO にデータがあれば 1 ビート AW を発行
                    if (w_pixels_rem != 32'd0) && (wrt_count != 12'd0) && (AWVALID == 1'b0) {
                        AWADDR  = w_addr;
                        AWLEN   = 8'd0; // 1 beat burst
                        AWVALID = 1'b1;
                    }

                    if AWVALID && AWREADY {
                        AWVALID      = 1'b0;
                        w_addr       = w_addr + 32'd4;
                        w_pixels_rem = w_pixels_rem - 32'd1;

                        // 次のサイクルで FIFO から 1 ワード取りたい
                        wrt_rd_en = 1'b1;
                        w_state   = WState::data;
                    }
                }

                WState::data: {
                    // まだ WVALID_r=0（データを持っていない）なら、FIFO から 1 ワードラッチ
                    if !WVALID_r {
                        if wrt_valid {
                            WDATA_r  = wrt_dout;
                            WLAST_r  = 1'b1; // 常に 1 ビートバーストなので必ず last
                            WVALID_r = 1'b1; // ここから WVALID=1
                        } else if !wrt_empty {
                            // valid がまだなら rd_en を出して次サイクルを待つ
                            wrt_rd_en = 1'b1;
                        }
                    }

                    if WVALID_r {
                        if WREADY {
                            // ハンドシェイク成立：このビートを消費
                            WVALID_r = 1'b0;
                            WLAST_r  = 1'b0;
                            w_state  = WState::wait;
                        } else {
                            // WREADY=0 の間は WDATA_r / WLAST_r / WVALID_r を一切変更しない
                        }
                    }
                }

                WState::wait: {
                    // B レスポンスを待つ
                    if BVALID && BREADY {
                        if (w_pixels_rem == 32'd0) {
                            // フレーム分すべて書き終わった
                            w_state = WState::idle;
                        } else {
                            // まだ残りがあるので次のピクセルへ
                            w_state = WState::addr;
                        }
                    }
                }
            }
        }
    }
}
