/// VRAM Control
///
/// - Read the source image from DDR via the AXI bus.
/// - Store the read source image into the source FIFO (src FIFO).
/// - Read data from the source FIFO and send it to fit_proc.
/// - Store the post-filter data into the write FIFO (wrt FIFO).
/// - Read data from the write FIFO and write it back to DDR.
pub module flt_vramctrl (
    CLK : input clock,
    ARST: input reset,
    RSTS: input reset, // module reset (High)

    RESOL: input Resolution::Mode,

    // Read Address
    ARADDR : output logic<32>,
    ARVALID: output logic    ,
    ARLEN  : output logic<8> ,
    ARREADY: input  logic    ,

    // Read Data
    RDATA : input  logic<32>,
    RLAST : input  logic    ,
    RVALID: input  logic    ,
    RREADY: output logic    ,

    // Write Address
    AWADDR : output logic<32>,
    AWVALID: output logic    ,
    AWLEN  : output logic<8> ,
    AWREADY: input  logic    ,

    // Write Data
    WDATA : output logic<32>,
    WLAST : output logic    ,
    WVALID: output logic    ,
    WSTRB : output logic<4> ,
    WREADY: input  logic    ,

    // Response
    BVALID: input  logic,
    BREADY: output logic,

    FLTRG_START  : input logic    ,
    FLTRG_VRAMSRC: input logic<32>,
    FLTRG_VRAMFRM: input logic<32>,

    FLTPC_WDATAVLD: input logic    ,
    FLTPC_WDATA   : input logic<32>,

    FLTVC_SDATAVLD: output logic    ,
    FLTVC_SDATA   : output logic<32>,

    FLTVC_BUSY: output logic,
    FLTVC_INT : output logic,
) {
    let rst: '_ default reset_sync_high = ARST | RSTS;

    const BURST_LEN: u32 = 32;
    const BURST_VAL: u32 = 8'd31;

    var r_pix_cnt     : logic<32>; // read pixel counter
    var w_pix_cnt     : logic<32>; // write pixel counter
    var r_addr_current: logic<32>; // current read address
    var w_addr_current: logic<32>; // current write address

    enum State {
        idle,
        addr,
        data,
        resp,
    }
    var r_state: State;
    var w_state: State;

    // decode RESOL
    let total_pixels: logic<32> = case RESOL {
        Resolution::Mode::vga : 640 * 480,
        Resolution::Mode::xga : 1024 * 768,
        Resolution::Mode::sxga: 1280 * 1024,
        default               : 640 * 480,
    };

    // BUSY, INT
    always_ff {
        if_reset {
            FLTVC_BUSY = 1'b0;
            FLTVC_INT  = 1'b0;
        } else {
            if FLTRG_START {
                FLTVC_BUSY = 1'b1;
            } else if FLTVC_BUSY && (w_pix_cnt >= total_pixels) {
                // writing is done
                FLTVC_BUSY = 1'b0;
                FLTVC_INT  = 1'b1;
            } else {
                FLTVC_INT = 1'b0;
            }
        }
    }

    // Read Channel FSM
    assign src_wr_en = RVALID && RREADY;

    always_ff {
        if_reset {
            r_addr_current = 32'h0;
        } else if FLTRG_START {
            r_addr_current = FLTRG_VRAMSRC; // initial value
        } else if ARVALID && ARREADY {
            r_addr_current += BURST_LEN * 4;
        }
    }

    // count pixels
    always_ff {
        if_reset {
            r_pix_cnt = 32'h0;
        } else if FLTRG_START {
            r_pix_cnt = 32'h0;
        } else if src_wr_en {
            r_pix_cnt += 1;
        }
    }

    // Read FSM
    always_ff {
        if_reset {
            r_state = State::idle;
            ARVALID = 1'b0;
            RREADY  = 1'b0;
        } else {
            case r_state {
                State::idle: {
                    ARVALID = 1'b0;
                    if FLTVC_BUSY && (r_pix_cnt <: total_pixels) && (src_count <: (2048 - BURST_LEN)) {
                        // in burst, data is available and fifo has space
                        r_state = State::addr;
                        ARVALID = 1'b1;
                        // 32 の倍数を仮定
                        ARLEN  = BURST_VAL;
                        ARADDR = r_addr_current;
                    }
                }
                State::addr: {
                    if ARREADY {
                        ARVALID = 1'b0;
                        r_state = State::data;
                        RREADY  = 1'b1;
                    }
                }
                State::data: {
                    if RLAST && RVALID && RREADY {
                        RREADY  = 1'b0;
                        r_state = State::idle;
                    }
                }
            }
        }
    }

    // Source data FIDO (R -> PROC)
    var src_dout : logic<32>;
    var src_empty: logic    ;
    var src_full : logic    ;
    var src_valid: logic    ;
    var src_rd_en: logic    ;
    var src_wr_en: logic    ;
    var src_count: logic<12>;

    inst u_fifo_src: $sv::fifo_32in32out_2048depth (
        clk       : CLK      ,
        din       : RDATA    ,
        rd_en     : src_rd_en,
        rst       : rst      ,
        wr_en     : src_wr_en,
        dout      : src_dout ,
        empty     : src_empty,
        full      : src_full ,
        overflow  : _        ,
        valid     : src_valid,
        underflow : _        ,
        data_count: src_count,
    );

    // Write data FIFO (PROC -> W)
    var wrt_dout : logic<32>;
    var wrt_empty: logic    ;
    var wrt_full : logic    ;
    var wrt_valid: logic    ;
    var wrt_rd_en: logic    ;
    var wrt_wr_en: logic    ;
    var wrt_count: logic<12>;

    inst u_fifo_wrt: $sv::fifo_32in32out_2048depth (
        clk       : CLK        ,
        din       : FLTPC_WDATA,
        rd_en     : wrt_rd_en  ,
        rst       : rst        ,
        wr_en     : wrt_wr_en  ,
        dout      : wrt_dout   ,
        empty     : wrt_empty  ,
        full      : wrt_full   ,
        overflow  : _          ,
        valid     : wrt_valid  ,
        underflow : _          ,
        data_count: wrt_count  ,
    );
}
