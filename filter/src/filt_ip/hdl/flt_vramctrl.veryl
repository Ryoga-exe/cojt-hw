/// VRAM Control
///
/// - Read the source image from DDR via the AXI bus.
/// - Store the read source image into the source FIFO (src FIFO).
/// - Read data from the source FIFO and send it to fit_proc.
/// - Store the post-filter data into the write FIFO (wrt FIFO).
/// - Read data from the write FIFO and write it back to DDR.
pub module flt_vramctrl (
    CLK : input clock,
    ARST: input reset,
    RSTS: input reset, // module reset (High)

    RESOL: input Resolution::Mode,

    // Read Address
    ARADDR : output logic<32>,
    ARVALID: output logic    ,
    ARLEN  : output logic<8> ,
    ARREADY: input  logic    ,

    // Read Data
    RDATA : input  logic<32>,
    RLAST : input  logic    ,
    RVALID: input  logic    ,
    RREADY: output logic    ,

    // Write Address
    AWADDR : output logic<32>,
    AWVALID: output logic    ,
    AWLEN  : output logic<8> ,
    AWREADY: input  logic    ,

    // Write Data
    WDATA : output logic<32>,
    WLAST : output logic    ,
    WVALID: output logic    ,
    WSTRB : output logic<4> ,
    WREADY: input  logic    ,

    // Response
    BVALID: input  logic,
    BREADY: output logic,

    FLTRG_START  : input logic    ,
    FLTRG_VRAMSRC: input logic<32>,
    FLTRG_VRAMFRM: input logic<32>,

    FLTPC_WDATAVLD: input logic    ,
    FLTPC_WDATA   : input logic<32>,

    FLTVC_SDATAVLD: output logic    ,
    FLTVC_SDATA   : output logic<32>,

    FLTVC_BUSY: output logic,
    FLTVC_INT : output logic,
) {
    // Reset definition (Combined ARST and RSTS)
    let rst: '_ default reset_sync_high = ARST | RSTS;

    const BURST_LEN: u32 = 32;
    const BURST_VAL: u32 = 8'd31;

    var ar_pix_cnt    : logic<32>;
    var w_pix_cnt     : logic<32>;
    var r_addr_current: logic<32>;
    var w_addr_current: logic<32>;

    // FIFO declarations (Moved up for scope visibility)
    var src_dout : logic<32>;
    var src_empty: logic    ;
    var src_full : logic    ;
    var src_valid: logic    ;
    var src_rd_en: logic    ;
    var src_wr_en: logic    ;
    var src_count: logic<12>;

    var wrt_dout : logic<32>;
    var wrt_empty: logic    ;
    var wrt_full : logic    ;
    var wrt_valid: logic    ;
    var wrt_rd_en: logic    ;
    var wrt_wr_en: logic    ;
    var wrt_count: logic<12>;

    enum State {
        idle,
        addr,
        data,
        resp,
    }
    var r_state: State;
    var w_state: State;

    // decode RESOL
    let total_pixels: logic<32> = case RESOL {
        Resolution::Mode::vga : 640 * 480,
        Resolution::Mode::xga : 1024 * 768,
        Resolution::Mode::sxga: 1280 * 1024,
        default               : 640 * 480,
    };

    // BUSY, INT
    always_ff {
        if_reset {
            FLTVC_BUSY = 1'b0;
            FLTVC_INT  = 1'b0;
        } else {
            if FLTRG_START {
                FLTVC_BUSY = 1'b1;
                FLTVC_INT  = 1'b0;
            } else if FLTVC_BUSY && (w_pix_cnt >= total_pixels) {
                FLTVC_BUSY = 1'b0;
                FLTVC_INT  = 1'b1;
            } else {
                FLTVC_INT = 1'b0;
            }
        }
    }

    //-------------------------------------------------------------------------
    // Read Channel FSM
    //-------------------------------------------------------------------------
    assign src_wr_en = RVALID && RREADY;

    // address
    always_ff {
        if_reset {
            r_addr_current = 32'h0;
        } else if FLTRG_START {
            r_addr_current = FLTRG_VRAMSRC;
        } else if ARVALID && ARREADY {
            r_addr_current += BURST_LEN * 4;
        }
    }

    // count pixels
    always_ff {
        if_reset {
            ar_pix_cnt = 32'h0;
        } else if FLTRG_START {
            ar_pix_cnt = 32'h0;
        } else if ARVALID && ARREADY {
            ar_pix_cnt = ar_pix_cnt + BURST_LEN;
        }
    }

    // Read FSM
    always_ff {
        if_reset {
            r_state = State::idle;
            ARVALID = 1'b0;
            RREADY  = 1'b0;
            ARADDR  = 32'h0;
            ARLEN   = 8'h0;
        } else {
            case r_state {
                State::idle: {
                    ARVALID = 1'b0;
                    if FLTVC_BUSY && (ar_pix_cnt <: total_pixels) && (src_count <: (2048 - BURST_LEN * 2)) {
                        r_state = State::addr;
                        ARVALID = 1'b1;
                        ARLEN   = BURST_VAL;
                        ARADDR  = r_addr_current;
                    }
                }
                State::addr: {
                    if ARREADY {
                        ARVALID = 1'b0;
                        r_state = State::data;
                        RREADY  = 1'b1;
                    }
                }
                State::data: {
                    if RLAST && RVALID && RREADY {
                        RREADY  = 1'b0;
                        r_state = State::idle;
                    }
                }
            }
        }
    }

    // filter proc connection
    assign src_rd_en      = !src_empty && (wrt_count <: (2048 - 32));
    assign FLTVC_SDATAVLD = src_valid;
    assign FLTVC_SDATA    = src_dout;

    //-------------------------------------------------------------------------
    // Write Channel FSM
    //-------------------------------------------------------------------------
    assign wrt_wr_en = FLTPC_WDATAVLD;
    assign WSTRB     = 4'b1111;
    assign BREADY    = 1'b1;

    // address update
    always_ff {
        if_reset {
            w_addr_current = 32'h0;
        } else if FLTRG_START {
            w_addr_current = FLTRG_VRAMFRM;
        } else if AWVALID && AWREADY {
            w_addr_current += BURST_LEN * 4;
        }
    }

    // count pixels
    always_ff {
        if_reset {
            w_pix_cnt = 32'h0;
        } else if FLTRG_START {
            w_pix_cnt = 32'h0;
        } else if WVALID && WREADY {
            w_pix_cnt += 1;
        }
    }

    // Write FSM
    var w_burst_cnt: logic<8>;
    always_ff {
        if_reset {
            w_state     = State::idle;
            AWVALID     = 1'b0;
            WVALID      = 1'b0;
            WLAST       = 1'b0;
            AWADDR      = 32'h0;
            AWLEN       = 8'h0;
            w_burst_cnt = 0;
        } else {
            case w_state {
                State::idle: {
                    let remain_pix   : logic<32> = total_pixels - w_pix_cnt;
                    let is_last_burst: logic     = (remain_pix <= BURST_LEN) && (remain_pix >: 0);

                    if FLTVC_BUSY && ((wrt_count >= BURST_LEN) || (is_last_burst && wrt_count >= remain_pix)) {
                        w_state = State::addr;
                        AWVALID = 1'b1;
                        AWADDR  = w_addr_current;

                        if remain_pix <: BURST_LEN {
                            AWLEN = remain_pix[7:0] - 1'b1;
                        } else {
                            AWLEN = BURST_VAL;
                        }
                    }
                }
                State::addr: {
                    if AWREADY {
                        AWVALID = 1'b0;
                        w_state = State::data;
                        WVALID  = 1'b1;

                        // Initialize burst control logic here
                        w_burst_cnt = 0;
                        WLAST       = 0;
                        if AWLEN == 0 {
                            WLAST = 1'b1;
                        }
                    }
                }
                State::data: {
                    if WREADY {
                        if w_burst_cnt == AWLEN {
                            // End of burst
                            WVALID  = 1'b0;
                            WLAST   = 1'b0;
                            w_state = State::resp;
                        } else {
                            w_burst_cnt += 1;
                            if w_burst_cnt == (AWLEN - 1) {
                                WLAST = 1'b1; // Set WLAST 1 cycle before end
                            }
                        }
                    }
                }
                State::resp: {
                    if BVALID {
                        w_state = State::idle;
                    }
                }
            }
        }
    }

    // FIFO read enable
    assign wrt_rd_en = (w_state == State::data) && WREADY;
    assign WDATA     = wrt_dout;

    // Instantiations
    inst u_fifo_src: $sv::fifo_32in32out_2048depth (
        clk       : CLK      ,
        din       : RDATA    ,
        rd_en     : src_rd_en,
        rst       : rst      ,
        wr_en     : src_wr_en,
        dout      : src_dout ,
        empty     : src_empty,
        full      : src_full ,
        overflow  : _        ,
        valid     : src_valid,
        underflow : _        ,
        data_count: src_count,
    );

    inst u_fifo_wrt: $sv::fifo_32in32out_2048depth (
        clk       : CLK        ,
        din       : FLTPC_WDATA,
        rd_en     : wrt_rd_en  ,
        rst       : rst        ,
        wr_en     : wrt_wr_en  ,
        dout      : wrt_dout   ,
        empty     : wrt_empty  ,
        full      : wrt_full   ,
        overflow  : _          ,
        valid     : wrt_valid  ,
        underflow : _          ,
        data_count: wrt_count  ,
    );
}
