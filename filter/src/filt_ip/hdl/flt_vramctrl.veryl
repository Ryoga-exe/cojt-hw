/// VRAM Control
///
/// - フレーム全体を 32bit/pixel のストリームとして扱う
/// - READ:
///   - FLTRG_VRAMSRC から width*height 個の 32bit を AXI4-Read
///   - 各 RVALID&RREADY のビートを **そのまま** FLTVC_SDATA/FLTVC_SDATAVLD に出力
///     → RDATA のビート数と完全に 1:1 対応する
/// - WRITE:
///   - flt_proc の出力 FLTPC_WDATA を AXI4-Write で FLTRG_VRAMFRM へ書き戻し
///   - 1 ビート固定バースト (AWLEN=0) で、WVALID/WLAST をレジスタ保持
/// - FLTVC_BUSY:
///   - FLTRG_START 立ち上がりで 1
///   - フレームの Read/Write が完了したら 0
/// - FLTVC_INT:
///   - BUSY の立ち下がりで 1 パルス
pub module flt_vramctrl (
    CLK : input clock,
    ARST: input reset,
    RSTS: input reset, // synchronous-high module reset

    RESOL: input Resolution::Mode,

    // Read Address
    ARADDR : output logic<32>,
    ARVALID: output logic    ,
    ARLEN  : output logic<8> ,
    ARREADY: input  logic    ,

    // Read Data
    RDATA : input  logic<32>,
    RLAST : input  logic    ,
    RVALID: input  logic    ,
    RREADY: output logic    ,

    // Write Address
    AWADDR : output logic<32>,
    AWVALID: output logic    ,
    AWLEN  : output logic<8> ,
    AWREADY: input  logic    ,

    // Write Data
    WDATA : output logic<32>,
    WLAST : output logic    ,
    WVALID: output logic    ,
    WSTRB : output logic<4> ,
    WREADY: input  logic    ,

    // Response
    BVALID: input  logic,
    BREADY: output logic,

    // Control
    FLTRG_START  : input logic    ,
    FLTRG_VRAMSRC: input logic<32>,
    FLTRG_VRAMFRM: input logic<32>,

    // Filter I/F (to/from flt_proc)
    FLTPC_WDATAVLD: input logic    ,
    FLTPC_WDATA   : input logic<32>,

    FLTVC_SDATAVLD: output logic    ,
    FLTVC_SDATA   : output logic<32>,

    FLTVC_BUSY: output logic,
    FLTVC_INT : output logic,
) {
    // unified synchronous-high reset（ARST or RSTS）
    let rst: '_ default reset_sync_high = ARST | RSTS;

    const BLEN: u32 = 16; // READ 側の最大バースト長

    // ---------------- geometry ----------------
    var width : logic<16>;
    var height: logic<16>;
    always_comb {
        case RESOL {
            Resolution::Mode::vga: {
                width  = 16'd640;
                height = 16'd480;
            }
            Resolution::Mode::xga: {
                width  = 16'd1024;
                height = 16'd768;
            }
            Resolution::Mode::sxga: {
                width  = 16'd1280;
                height = 16'd1024;
            }
            default: {
                width  = 16'd640;
                height = 16'd480;
            }
        }
    }

    // フレーム総ピクセル数（=32bit ワード数）
    let frame_pixels: logic<32> = (width as 32) * (height as 32);

    // ---------------- start / BUSY / INT ----------------
    var start_q     : logic;
    var frame_active: logic;
    var busy_d      : logic;

    always_ff {
        if_reset {
            start_q = 1'b0;
        } else {
            start_q = FLTRG_START;
        }
    }

    let start_pulse: logic = FLTRG_START & ~start_q;

    // read/write の完了フラグ（後ろで決める）
    var read_done : logic;
    var write_done: logic;

    assign FLTVC_BUSY = frame_active;

    always_ff {
        if_reset {
            frame_active = 1'b0;
            busy_d       = 1'b0;
            FLTVC_INT    = 1'b0;
        } else {
            busy_d = frame_active;

            // フレーム開始
            if start_pulse && (frame_active == 1'b0) {
                frame_active = 1'b1;
            } else if frame_active && read_done && write_done {
                frame_active = 1'b0;
            }

            // BUSY 立ち下がりで INT
            FLTVC_INT = (busy_d == 1'b1) && (frame_active == 1'b0);
        }
    }

    // =====================================================
    // READ: AXI AR/R → FLTVC_SDATA/SDATAVLD（ストリーム）
    // =====================================================
    enum RState {
        idle,
        set_addr,
        read,
    }

    var r_state     : RState    ;
    var r_addr      : logic <32>;
    var r_pixels_rem: logic <32>; // 残りピクセル数（=残り 32bit ワード数）
    var r_beats_rem : logic <8> ; // 現在のバースト残りビート数
    var r_inflight  : logic     ; // R チャネルで未完了のバーストがあるか

    var want8: logic<8>; // 次のバーストで取りたいビート数

    // want8 の決定と read_done 判定
    always_comb {
        let blen8 : logic<8>  = BLEN as 8;
        let blen32: logic<32> = BLEN as 32;

        if r_pixels_rem >: blen32 {
            want8 = blen8;
        } else if r_pixels_rem != 0 {
            want8 = r_pixels_rem[7:0];
        } else {
            want8 = 8'd0;
        }

        // 読み出し完了条件:
        // - 残りピクセルが 0
        // - FSM が idle（追加の AR/R はもうない）
        read_done = (r_pixels_rem == 32'd0) && (r_state == RState::idle);
    }

    always_ff {
        if_reset {
            ARADDR  = 32'd0;
            ARLEN   = 8'd0;
            ARVALID = 1'b0;
            RREADY  = 1'b0;

            r_state      = RState::idle;
            r_addr       = 32'd0;
            r_pixels_rem = 32'd0;
            r_beats_rem  = 8'd0;
            r_inflight   = 1'b0;

            FLTVC_SDATA    = 32'd0;
            FLTVC_SDATAVLD = 1'b0;
        } else {
            // デフォルト
            RREADY         = 1'b0;
            FLTVC_SDATAVLD = 1'b0;

            case r_state {
                RState::idle: {
                    ARVALID = 1'b0;

                    // フレーム開始時に初期化
                    if start_pulse {
                        r_addr       = FLTRG_VRAMSRC;
                        r_pixels_rem = frame_pixels;
                        r_beats_rem  = 8'd0;
                        r_inflight   = 1'b0;
                        r_state      = RState::set_addr;
                    }
                }

                RState::set_addr: {
                    if r_pixels_rem == 32'd0 {
                        // もう読むものはない
                        ARVALID = 1'b0;
                        r_state = RState::idle;
                    } else {
                        // バースト要求
                        if !ARVALID && !r_inflight && (want8 != 8'd0) {
                            ARADDR  = r_addr;
                            ARLEN   = want8 - 8'd1; // beats-1
                            ARVALID = 1'b1;
                        }

                        if ARVALID && ARREADY {
                            ARVALID     = 1'b0;
                            r_inflight  = 1'b1;
                            r_beats_rem = want8;

                            let beats32     : logic<32> = want8 as 32;
                            r_addr       = r_addr + (beats32 << 2); // 4byte/beat
                            r_pixels_rem = r_pixels_rem - beats32;

                            r_state = RState::read;
                        }
                    }
                }

                RState::read: {
                    // バースト中は常に受け付ける
                    RREADY = 1'b1;

                    if RVALID && RREADY {
                        // RDATA 1 ビートをそのままフィルタへ
                        FLTVC_SDATA    = RDATA;
                        FLTVC_SDATAVLD = 1'b1;

                        r_beats_rem = r_beats_rem - 8'd1;

                        if RLAST || (r_beats_rem == 8'd1) {
                            r_inflight = 1'b0;

                            if r_pixels_rem != 32'd0 {
                                r_state = RState::set_addr;
                            } else {
                                r_state = RState::idle;
                            }
                        }
                    }
                }
            }
        }
    }

    // =====================================================
    // WRITE: flt_proc 出力 → AXI AW/W/B（1 beat bursts）
    // =====================================================
    //
    // - FLTPC_WDATA/WDATAVLD を AXI Write で書き戻す
    // - AWLEN = 0 (1 ビートバースト固定)
    // - WDATA / WVALID / WLAST はレジスタ WDATA_r / WVALID_r / WLAST_r で保持
    // - WVALID_r == 1 && WREADY == 0 の間は一切変えない（WLAST 安定条件を満たす）
    enum WState {
        idle,
        set_addr,
        write,
        wait_b,
    }

    var w_state      : WState    ;
    var w_addr       : logic <32>;
    var w_pixels_rem : logic <32>; // まだ書くべきピクセル数
    var w_pixels_sent: logic <32>; // 実際に書いたピクセル数

    // 出力レジスタ
    var WDATA_r : logic<32>;
    var WLAST_r : logic    ;
    var WVALID_r: logic    ;

    assign WDATA  = WDATA_r;
    assign WLAST  = WLAST_r;
    assign WVALID = WVALID_r;
    assign WSTRB  = 4'hF;
    assign BREADY = (w_state == WState::wait_b);

    // write_done 判定（「送るべきピクセル数を書き終えた」）
    always_comb {
        write_done = (w_pixels_rem == 32'd0) && (w_state == WState::idle) && (WVALID_r == 1'b0) && (AWVALID == 1'b0);
    }

    always_ff {
        if_reset {
            w_state       = WState::idle;
            AWADDR        = 32'd0;
            AWLEN         = 8'd0;
            AWVALID       = 1'b0;
            w_addr        = 32'd0;
            w_pixels_rem  = 32'd0;
            w_pixels_sent = 32'd0;

            WDATA_r  = 32'd0;
            WLAST_r  = 1'b0;
            WVALID_r = 1'b0;
        } else {
            case w_state {
                WState::idle: {
                    // 出力レジスタは idle でクリア（WVALID は 0 のまま）
                    WLAST_r = 1'b0;

                    // フレーム開始時に初期化
                    if start_pulse {
                        w_addr        = FLTRG_VRAMFRM;
                        w_pixels_rem  = frame_pixels;
                        w_pixels_sent = 32'd0;
                    }

                    // フレームアクティブ & 書くべきピクセルが残っていて
                    // かつ flt_proc からのデータが存在する場合に書き込み開始
                    if frame_active && (w_pixels_rem != 32'd0) && FLTPC_WDATAVLD {
                        w_state = WState::set_addr;
                    }
                }

                WState::set_addr: {
                    if !frame_active {
                        AWVALID = 1'b0;
                        w_state = WState::idle;
                    } else if w_pixels_rem == 32'd0 {
                        AWVALID = 1'b0;
                        w_state = WState::idle;
                    } else {
                        if AWVALID == 1'b0 {
                            AWADDR  = w_addr;
                            AWLEN   = 8'd0; // 1 beat burst
                            AWVALID = 1'b1;
                        }

                        if AWVALID && AWREADY {
                            AWVALID = 1'b0;
                            // 次のワード用にアドレスを進めておく
                            w_addr = w_addr + 32'd4;

                            // 今回書くデータをキャプチャ
                            // （set_addr に入る条件で FLTPC_WDATAVLD==1 を保証）
                            WDATA_r  = FLTPC_WDATA;
                            WLAST_r  = 1'b1;
                            WVALID_r = 1'b1;

                            w_state = WState::write;
                        }
                    }
                }

                WState::write: {
                    // WVALID_r == 1 の間は、WREADY が 0 なら何も変えない
                    if WVALID_r {
                        if WREADY {
                            // ハンドシェイク成功
                            WVALID_r = 1'b0;
                            WLAST_r  = 1'b0;

                            // 1 ピクセル分書き終えた
                            if w_pixels_rem != 32'd0 {
                                w_pixels_rem = w_pixels_rem - 32'd1;
                            }
                            w_pixels_sent = w_pixels_sent + 32'd1;

                            w_state = WState::wait_b;
                        } else {
                            // WREADY=0 の間は WDATA_r/WLAST_r/WVALID_r を保持
                        }
                    }
                }

                WState::wait_b: {
                    if BVALID && BREADY {
                        if frame_active && (w_pixels_rem != 32'd0) && FLTPC_WDATAVLD {
                            // まだ書くべきピクセルが残っていて、次の入力もある
                            w_state = WState::set_addr;
                        } else {
                            // 一旦 idle に戻って write_done 判定へ
                            w_state = WState::idle;
                        }
                    }
                }
            }
        }
    }
}
