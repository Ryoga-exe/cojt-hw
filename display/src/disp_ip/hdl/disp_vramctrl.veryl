/// VRAM controller
pub module disp_vramctrl (
    // System Signals
    ACLK: input clock, /// system clock
    ARST: input reset, /// system reset

    // Address Read
    ARADDR : output logic<32>,
    ARVALID: output logic    ,
    ARREADY: input  logic    ,

    // Read Data
    RLAST : input  logic,
    RVALID: input  logic,
    RREADY: output logic,

    // Resolution
    RESOL: input Resolution::Mode,

    // Signal by other modules
    VRSTART   : input logic    ,
    DISPON    : input logic    ,
    DISPADDR  : input logic<32>,
    BUF_WREADY: input logic    ,
) {
    var hsc: logic<11>;
    var hfp: logic<6> ;
    var hpw: logic<8> ;
    var hbp: logic<8> ;
    var hdo: logic<11>;
    var vsc: logic<11>;
    var vfp: logic<4> ;
    var vpw: logic<3> ;
    var vbp: logic<6> ;
    var vdo: logic<11>;

    inst i_tming: SyncgenTimingSel (
        mode: RESOL,
        hsc        ,
        hfp        ,
        hpw        ,
        hbp        ,
        hdo        ,
        vsc        ,
        vfp        ,
        vpw        ,
        vbp        ,
        vdo        ,
    );

    // Sync VRSTART
    var vr_meta: logic;
    var vr_sync: logic;
    var vr_prev: logic;
    always_ff {
        if_reset {
            vr_meta = 0'b0;
            vr_sync = 0'b0;
            vr_prev = 0'b0;
        } else {
            vr_meta = VRSTART;
            vr_sync = vr_meta;
            vr_prev = vr_sync;
        }
    }
    let vr_posedge: logic = vr_sync & ~vr_prev; // rise time

    // frame length (words)
    let words_in_frame: logic<32> = (hdo * vdo) >> 1; // width * height * 4 / 8 (8byte/word)
    const ADDR_INCR     : logic<32> = 32'd8;

    // Latch when VRSTART rise
    var frame_len: logic<32>;
    always_ff {
        if_reset {
            frame_len = 32'd0;
        } else if vr_posedge {
            frame_len = words_in_frame;
        }
    }

    // AXI Read Address FSM
    enum State {
        idle,
        addr,
        wait,
    }
    var cur_state: State;
    var nxt_state: State;

    var araddr_reg: logic<32>;
    var word_cnt  : logic<32>;

    // FSM: next state
    always_comb {
        nxt_state = cur_state;
        #[cond_type(unique)]
        case cur_state {
            State::idle: {
                if vr_posedge & DISPON {
                    nxt_state = State::addr;
                }
            }
            State::addr: {
                if ~BUF_WREADY {
                    nxt_state = State::wait;
                } else if (word_cnt == frame_len) && (ARVALID && ARREADY) {
                    nxt_state = State::idle;
                }
            }
            State::wait: {
                if BUF_WREADY {
                    nxt_state = State::addr;
                }
            }
        }
    }

    // FSM: update state, output
    always_ff {
        if_reset {
            cur_state  = State::idle;
            ARVALID    = 1'b0;
            ARADDR     = 32'h0;
            araddr_reg = 32'h0;
            word_cnt   = 32'd0;
        } else {
            cur_state = nxt_state;

            case cur_state {
                State::idle: {
                    ARVALID  = 1'b0;
                    word_cnt = 32'd0;
                    if nxt_state == State::addr {
                        ARADDR   = DISPADDR;
                        ARVALID  = 1'b1;
                        word_cnt = 32'd1;
                    }
                }
                State::addr: {
                    if ~BUF_WREADY {
                        ARVALID = 1'b0;
                    } else if ARVALID && ARREADY {
                        if word_cnt <: frame_len {
                            ARADDR   += ADDR_INCR;
                            word_cnt += 1;
                        } else {
                            ARVALID = 1'b0;
                        }
                    }
                }
                State::wait: {
                    if BUF_WREADY {
                        ARVALID = 1'b1;
                    }
                }
            }
        }
    }

    assign RREADY = 1'b1;
}
